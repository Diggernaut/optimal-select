{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///optimal-select.min.js","webpack:///webpack/bootstrap 783d9c26cba2349ca337","webpack:///./src/utilities.js","webpack:///./src/match.js","webpack:///./src/pattern.js","webpack:///./src/selector.js","webpack:///./src/common.js","webpack:///./src/optimize.js","webpack:///./src/select.js","webpack:///./~/sizzle/dist/sizzle.js","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","length","err","Array","isArray","TypeError","convertNodeList","nodes","escapeValue","replace","partition","array","predicate","reduce","_ref","item","_ref2","inner","outer","concat","isValidCSSIdentifier","test","_toConsumableArray","arr2","from","match","node","options","arguments","nested","initOptions","_options","skip","ignore","format","path","element","select","_selector","getSelect","toString","_pattern","getToString","skipCompare","map","entry","skipChecks","some","compare","keys","forEach","type","RegExp","_utilities","nodeType","checkAttributes","checkTag","includes","checkRecursiveDescendants","checkText","checkNthChild","parentNode","pattern","findPattern","unshift","checkIgnore","combinations","defaultIgnore","_typeof","obj","constructor","_extends","assign","target","source","key","default","attribute","attributeName","indexOf","contains","document","priority","parent","findAttributesPattern","values","min","max","result","v","r","shift","filter","maxSubsetSize","items","getClassSelector","classes","base","_ref3","find","_ref4","attributes","attributeNames","val","a","sortedKeys","createPattern","tag","tagName","toLowerCase","isOptimal","attributeValue","useNamedIgnore","currentIgnore","currentDefaultIgnore","_ret","classNames","trim","split","classIgnore","class","className","_ref5","findTagPattern","matches","_ref6","children","child","childPattern","relates","pseudo","console","warn","_ref7","textContent","firstChild","nodeValue","texts","text","descendants","querySelectorAll","descendantPath","startsWith","parentElement","_ref8","defaultPredicate","check","descendantsToXPath","pathToXPath","patternToXPath","pseudoToXPath","classesToXPath","attributesToXPath","pathToSelector","patternToSelector","pseudoToSelector","classesToSelector","attributesToSelector","join","convertEscaping","css","xpath","jquery","Sizzle","selectJQuery","selector","selectXPath","doc","evaluate","elements","iterateNext","selectCSS","getCommonProperties","getCommonAncestor","_match","_options$root","ancestors","index","parents","sort","curr","shallowAncestor","ancestor","_loop","otherParents","otherParent","_options$ignore","commonProperties","commonClasses","commonAttributes","commonTag","getAttribute","cls","elementAttributes","attributesNames","commonAttributesNames","nextCommonAttributes","optimize","Error","_pattern2","optimizePart","endOptimized","slice","shortened","pop","current","every","compareResults","optimizeText","pre","post","_partition","_partition2","other","optimized","optimizeAttributes","simplify","original","getSimplified","simplified","optimizeDescendant","descendant","optimizeRecursiveDescendants","optimizeNthOfType","findIndex","nthOfType","optimizeClasses","references","_loop2","reference","description","_ret2","optimizers","acc","optimizer","_interopRequireDefault","getQuerySelector","input","getMultiSelectorPath","getSingleSelectorPath","HTMLElement","_match2","_optimize","_optimize2","_common","ancestorPath","commonPath","getCommonPath","descendantPattern","selectorPath","selectorMatches","_getCommonProperties","__WEBPACK_AMD_DEFINE_RESULT__","window","context","results","seed","elem","nid","groups","newSelector","newContext","ownerDocument","setDocument","documentIsHTML","rquickExpr","exec","getElementById","id","apply","getElementsByTagName","support","getElementsByClassName","qsa","nonnativeSelectorCache","rbuggyQSA","nodeName","rdescend","rcombinators","rsibling","testContext","scope","rcssescape","fcssescape","setAttribute","expando","tokenize","toSelector","qsaError","removeAttribute","rtrim","createCache","cache","Expr","cacheLength","markFunction","fn","assert","el","createElement","e","removeChild","addHandle","attrs","handler","attrHandle","siblingCheck","b","cur","diff","sourceIndex","nextSibling","createInputPseudo","createButtonPseudo","createDisabledPseudo","disabled","isDisabled","inDisabledFieldset","createPositionalPseudo","argument","j","matchIndexes","setFilters","tokens","len","addCombinator","matcher","combinator","dir","checkNonElements","doneName","first","xml","oldCache","uniqueCache","outerCache","newCache","dirruns","uniqueID","elementMatcher","matchers","multipleContexts","contexts","condense","unmatched","newUnmatched","mapped","setMatcher","preFilter","postFilter","postFinder","postSelector","temp","preMap","postMap","preexisting","elems","matcherIn","matcherOut","splice","matcherFromTokens","checkContext","leadingRelative","relative","implicitRelative","matchContext","matchAnyContext","ret","outermostContext","matcherFromGroupMatchers","elementMatchers","setMatchers","bySet","byElement","superMatcher","outermost","matchedCount","setMatched","contextBackup","dirrunsUnique","Math","random","uniqueSort","getText","isXML","compile","sortInput","hasDuplicate","docElem","rbuggyMatches","Date","preferredDoc","classCache","tokenCache","compilerCache","sortOrder","hasOwn","pushNative","list","booleans","whitespace","identifier","pseudos","rwhitespace","rcomma","rpseudo","ridentifier","matchExpr","ID","CLASS","TAG","ATTR","PSEUDO","CHILD","bool","needsContext","rhtml","rinputs","rheader","rnative","runescape","funescape","escape","nonHex","high","String","fromCharCode","ch","asCodePoint","charCodeAt","unloadHandler","childNodes","els","namespace","namespaceURI","documentElement","hasCompare","subWindow","defaultView","top","addEventListener","attachEvent","appendChild","createComment","getById","getElementsByName","attrId","getAttributeNode","tmp","innerHTML","matchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","msMatchesSelector","disconnectedMatch","compareDocumentPosition","adown","bup","sortDetached","aup","ap","bp","expr","attr","specified","sel","error","msg","duplicates","detectDuplicates","sortStable","selectors","createPseudo",">"," ","+","~","excess","unquoted","nodeNameSelector","operator","what","_argument","last","simple","forward","ofType","_context","nodeIndex","start","useCache","lastChild","args","idx","matched","not","has","lang","elemLang","hash","location","focus","activeElement","hasFocus","href","tabIndex","enabled","checked","selected","selectedIndex","empty","header","button","_matchIndexes","eq","even","odd","lt","gt","radio","checkbox","file","password","image","submit","reset","filters","parseOnly","soFar","preFilters","cached","token","compiled","_name","defaultValue","_sizzle","noConflict","_interopRequireWildcard","newObj","common","getMultiSelector","getSingleSelector","_select","_common2"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,cAAAD,IAEAD,EAAA,cAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAE,EAAAF,EACAG,GAAA,EACAV,WAUA,OANAK,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,GAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KA+DA,OAnCAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAG,EAAA,SAAAK,GAA2C,MAAAA,IAG3CR,EAAAS,EAAA,SAAAf,EAAAgB,EAAAC,GACAX,EAAAY,EAAAlB,EAAAgB,IACAG,OAAAC,eAAApB,EAAAgB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAX,EAAAkB,EAAA,SAAAvB,GACA,GAAAgB,GAAAhB,KAAAwB,WACA,WAA2B,MAAAxB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAK,GAAAS,EAAAE,EAAA,IAAAA,GACAA,GAIAX,EAAAY,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAlB,KAAAe,EAAAC,IAGtDrB,EAAAwB,EAAA,GAGAxB,IAAAyB,EAAA,KDgBM,SAAS9B,EAAQD,EAASM,GAEhC,YAGAa,QAAOC,eAAepB,EAAS,cAC7Bc,OAAO,GAGT,IAAIkB,GAAiB,WAAc,QAASC,GAAcC,EAAKzB,GAAK,GAAI0B,MAAeC,GAAK,EAAUC,GAAK,EAAWC,MAAKC,EAAW,KAAM,IAAK,GAAiCC,GAA7BC,EAAKP,EAAIQ,OAAOC,cAAmBP,GAAMI,EAAKC,EAAGG,QAAQC,QAAoBV,EAAKW,KAAKN,EAAG1B,QAAYL,GAAK0B,EAAKY,SAAWtC,GAA3D2B,GAAK,IAAoE,MAAOY,GAAOX,GAAK,EAAMC,EAAKU,EAAO,QAAU,KAAWZ,GAAMK,EAAW,QAAGA,EAAW,SAAO,QAAU,GAAIJ,EAAI,KAAMC,IAAQ,MAAOH,GAAQ,MAAO,UAAUD,EAAKzB,GAAK,GAAIwC,MAAMC,QAAQhB,GAAQ,MAAOA,EAAY,IAAIQ,OAAOC,WAAYxB,QAAOe,GAAQ,MAAOD,GAAcC,EAAKzB,EAAa,MAAM,IAAI0C,WAAU,2DE7EzkBC,mBAAkB,SAACC,GAG9B,IAAK,GAFGN,GAAWM,EAAXN,OACFb,EAAM,GAAIe,OAAMF,GACbtC,EAAI,EAAGA,EAAIsC,EAAQtC,IAC1ByB,EAAIzB,GAAK4C,EAAM5C,EAEjB,OAAOyB,IAWIoB,cAAc,SAACxC,GAAD,MACzBA,IAASA,EAAMyC,QAAQ,sCAAuC,QAC3DA,QAAQ,MAAO,MAKPC,YAAY,SAACC,EAAOC,GAAR,MACvBD,GAAME,OACJ,SAAAC,EAAiBC,GAAjB,GAAAC,GAAA9B,EAAA4B,EAAA,GAAEG,EAAFD,EAAA,GAASE,EAATF,EAAA,SAA0BJ,GAAUG,IAASE,EAAME,OAAOJ,GAAOG,IAAUD,EAAOC,EAAMC,OAAOJ,eAmBtFK,uBAAuB,SAACpD,GAAD,QAChCA,IAAU,qBAAqBqD,KAAKrD,KAAW,4CAA4CqD,KAAKrD,KFmG9F,SAASb,EAAQD,EAASM,GAEhC,YAwBA,SAAS8D,GAAmBlC,GAAO,GAAIe,MAAMC,QAAQhB,GAAM,CAAE,IAAK,GAAIzB,GAAI,EAAG4D,EAAOpB,MAAMf,EAAIa,QAAStC,EAAIyB,EAAIa,OAAQtC,IAAO4D,EAAK5D,GAAKyB,EAAIzB,EAAM,OAAO4D,GAAe,MAAOpB,OAAMqB,KAAKpC,GG7I3K,QAASqC,GAAMC,GAAoC,GAA9BC,GAA8BC,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,MAAhBC,EAAgBD,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,IAAAA,UAAA,EAChED,GAAUG,EAAYH,EAD0C,IAAAI,GAEzBJ,EAA/B3E,EAFwD+E,EAExD/E,KAAMgF,EAFkDD,EAElDC,KAAMC,EAF4CF,EAE5CE,OAAQC,EAFoCH,EAEpCG,OAEtBC,KACFC,EAAUV,EACVzB,EAASkC,EAAKlC,OACZoC,GAAS,EAAAC,EAAAC,WAAUZ,GACnBa,GAAW,EAAAC,EAAAC,aAAYf,GAEvBgB,EAAcX,IAAS7B,MAAMC,QAAQ4B,GAAQA,GAAQA,IAAOY,IAAI,SAACC,GACrE,MAAqB,kBAAVA,GACF,SAACT,GAAD,MAAaA,KAAYS,GAE3BA,IAGHC,EAAa,SAACV,GAClB,MAAOJ,IAAQW,EAAYI,KAAK,SAACC,GAAD,MAAaA,GAAQZ,KAmBvD,KAhBA/D,OAAO4E,KAAKhB,GAAQiB,QAAQ,SAACC,GAC3B,GAAIvC,GAAYqB,EAAOkB,EACE,mBAAdvC,KACc,gBAAdA,KACTA,EAAYA,EAAU4B,YAEC,gBAAd5B,KACTA,EAAY,GAAIwC,SAAO,EAAAC,EAAA7C,aAAYI,GAAWH,QAAQ,MAAO,UAEtC,iBAAdG,KACTA,EAAYA,EAAY,OAAS,MAGnCqB,EAAOkB,GAAQ,SAACjF,EAAMF,GAAP,MAAiB4C,GAAUS,KAAKrD,OAG1CoE,IAAYpF,GAA6B,KAArBoF,EAAQkB,UAAiB,CAClD,IAA4B,IAAxBR,EAAWV,GAAmB,CAEhC,GAAImB,EAAgBnB,EAASD,EAAMR,EAASU,EAAQG,EAAUxF,GAAO,KACrE,IAAIwG,EAASpB,EAASD,EAAMR,EAASU,EAAQG,EAAUxF,GAAO,KAG9DuG,GAAgBnB,EAASD,EAAMR,EAASU,EAAQG,GAC5CL,EAAKlC,SAAWA,GAClBuD,EAASpB,EAASD,EAAMR,EAASU,EAAQG,GAGvCL,EAAKlC,SAAWA,IAAW,EAAG,SAASwD,SAASvB,KAAYL,GAAUO,IAAYV,GACpFgC,EAA0BtB,EAASD,EAAMR,EAASU,EAAQG,GAGxDL,EAAKlC,SAAWA,IAAW,EAAG,QAAS,UAAUwD,SAASvB,IAC5DyB,EAAUvB,EAASD,EAAMR,EAASU,EAAQG,EAAqB,WAAXN,GAGlDC,EAAKlC,SAAWA,GAClB2D,EAAcxB,EAASD,EAAMR,GAIjCS,EAAUA,EAAQyB,WAClB5D,EAASkC,EAAKlC,OAGhB,GAAImC,IAAYpF,EAAM,CACpB,GAAM8G,GAAUC,EAAY3B,EAAST,EAASU,EAAQG,EACtDL,GAAK6B,QAAQF,GAGf,MAAO3B,GHiDT9D,OAAOC,eAAepB,EAAS,cAC7Bc,OAAO,IAETd,EAAQ+G,YAAc/G,EAAQgH,aAAehH,EAAQ4E,YAAc5E,EAAQiH,kBAAgB1E,EAE3F,IAAI2E,GAA4B,kBAAXxE,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUwE,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXzE,SAAyByE,EAAIC,cAAgB1E,QAAUyE,IAAQzE,OAAOd,UAAY,eAAkBuF,IAElQE,EAAWlG,OAAOmG,QAAU,SAAUC,GAAU,IAAK,GAAI9G,GAAI,EAAGA,EAAIiE,UAAU3B,OAAQtC,IAAK,CAAE,GAAI+G,GAAS9C,UAAUjE,EAAI,KAAK,GAAIgH,KAAOD,GAAcrG,OAAOS,UAAUC,eAAelB,KAAK6G,EAAQC,KAAQF,EAAOE,GAAOD,EAAOC,IAAY,MAAOF,GAMvPvH,GAAQ0H,QGrIgBnD,CApCxB,IAAAgB,GAAAjF,EAAA,GACA8E,EAAA9E,EAAA,GACA6F,EAAA7F,EAAA,GAQa2G,mBACXU,UAD2B,SACjBC,GACR,OACE,QACA,eACA,uBACAC,QAAQD,IAAkB,GAE9BE,SAAU,kBAAM,IAGLlD,gBAAc,cAACH,GAADC,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,YAAA2C,MACtB5C,GACH3E,KAAM2E,EAAQ3E,MAAQiI,SACtBjD,KAAML,EAAQK,MAAQ,KACtBkD,SAAUvD,EAAQuD,WAAa,KAAM,QAAS,OAAQ,OACtDjD,OAAQN,EAAQM,cA+FZsB,EAAkB,SAACnB,EAASD,EAAVrB,EAAsCuB,EAAQG,GAA0C,GAAtE0C,GAAsEpE,EAAtEoE,SAAUjD,EAA4DnB,EAA5DmB,OAA4BkD,EAAgCvD,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,GAAvBQ,EAAQyB,WACzFC,EAAUsB,EAAsBF,EAAU9C,EAASH,EAAQI,EAAQG,EAAU2C,EACnF,SAAIrB,IACF3B,EAAK6B,QAAQF,IACN,IAWEI,iBAAe,SAACmB,EAAQ1D,GAAY,GAAAX,GAC1BW,MAAb2D,EADuCtE,EACvCsE,IAAKC,EADkCvE,EAClCuE,IACPC,MAWN,OATAH,GAAOnC,QAAQ,SAAAuC,GACbD,EAAOtC,QAAQ,SAAAwC,KACRH,GAAOG,EAAEzF,OAASsF,IACrBC,EAAOxF,KAAK0F,EAAEvE,OAAOsE,QAK3BD,EAAOG,QACAL,EAAME,EAAOI,OAAO,SAAAF,GAAA,MAAKA,GAAEzF,QAAUqF,IAAOE,GAI/CK,IACFC,MAAO,GAAIP,IAAK,IAChBO,MAAO,GAAIP,IAAK,IAChBO,MAAO,EAAGP,IAAK,IACfO,MAAO,EAAGP,IAAK,IAabQ,EAAmB,WAMvB,IAAK,GANmBC,GAAiDpE,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,MAAnCS,EAAmCT,UAAA,GAA3BY,EAA2BZ,UAAA,GAAjBuD,EAAiBvD,UAAA,GAATqE,EAASrE,UAAA,GAAAsE,EAEvEL,EAAcM,KAAK,SAAAC,GAAA,GAAGN,GAAHM,EAAGN,KAAH,OAAeE,GAAQ/F,OAAS6F,MAAYP,IAAKS,EAAQ/F,QADtEsF,EADiEW,EACjEX,IAGJC,EAAStB,EAAa8B,GAAWT,QAE5B5H,EAAI,EAAGA,EAAI6H,EAAOvF,OAAQtC,IAAK,CAGtC,GAAuB,IADP0E,EADAG,EAASsB,QAATS,KAAsB0B,GAAMD,QAASR,EAAO7H,MAC5BwH,GACpBlF,OACV,MAAOuF,GAAO7H,GAIlB,MAAO,OAcHyH,EAAwB,SAACF,EAAU9C,EAASH,EAAQI,EAAQG,GAA0C,GAAhC2C,GAAgCvD,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,GAAvBQ,EAAQyB,WACrFwC,EAAajE,EAAQiE,WACvBC,EAAiBjI,OAAO4E,KAAKoD,GAAYzD,IAAI,SAAC2D,GAAD,MAASF,GAAWE,GAAKrI,OACvE0H,OAAO,SAACY,GAAD,MAAOtB,GAASH,QAAQyB,GAAK,IAEnCC,cAAiBvB,GAAjB5D,EAA8BgF,IAC9BxC,GAAU,EAAArB,EAAAiE,gBACd5C,GAAQ6C,IAAMvE,EAAQwE,QAAQC,aAI9B,KAAK,GAFDC,GAAY,SAAChD,GAAD,MAAmE,KAArDzB,EAAOG,EAASsB,QAAQA,GAAUqB,GAAQlF,QAE/DtC,EAAI,EAAGC,EAAI6I,EAAWxG,OAAQtC,EAAIC,EAAGD,IAAK,CACjD,GAAMgH,GAAM8B,EAAW9I,GACjBkH,EAAYwB,EAAW1B,GACvBG,GAAgB,EAAAzB,EAAA7C,aAAYqE,GAAaA,EAAU3G,MACnD6I,GAAiB,EAAA1D,EAAA7C,aAAYqE,GAAaA,EAAU7G,OACpDgJ,EAAmC,UAAlBlC,EAEjBmC,EAAiBD,GAAkB/E,EAAO6C,IAAmB7C,EAAO4C,UACpEqC,EAAwBF,GAAkB7C,EAAcW,IAAmBX,EAAcU,SAC/F,KAAIZ,EAAYgD,EAAenC,EAAeiC,EAAgBG,GAI9D,OAAQpC,GACN,IAAK,QAAS,GAAAqC,GAAA,WACZ,GAAIC,GAAaL,EAAeM,OAAOC,MAAM,OAC7C,KAAKF,EAAW,GACd,aAEF,IAAMG,GAActF,EAAOuF,OAASrD,EAAcqD,KAIlD,IAHID,IACFH,EAAaA,EAAWxB,OAAO,SAAA6B,GAAA,OAAcF,EAAYE,MAEvDL,EAAWnH,OAAS,EAAG,CACzB,GAAM+F,GAAUD,EAAiBqB,EAAY/E,EAAQG,EAAU2C,EAAQrB,EACvE,IAAIkC,IACFlC,EAAQkC,QAAUA,EACdc,EAAUhD,IACZ,OAAA2B,EAAO3B,MAdD,QAAAqD,GAAA,YAGV,KAHU,iCAAAA,EAAA,YAAA/C,EAAA+C,IAAA,MAAAA,GAAA1B,EAmBZ,KAEF,SAEE,GADA3B,EAAQuC,WAAWrG,MAAO9B,KAAM4G,EAAe9G,MAAO+I,IAClDD,EAAUhD,GACZ,MAAOA,IAKf,MAAO,OAeHN,EAAW,SAACpB,EAASD,EAAVuF,EAA4BrF,EAAQG,GAA0C,GAA5DP,GAA4DyF,EAA5DzF,OAA4BkD,EAAgCvD,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,GAAvBQ,EAAQyB,WACxEC,EAAU6D,EAAevF,EAASH,EACxC,IAAI6B,EAAS,CACX,GAAI8D,KAEJ,IADAA,EAAUvF,EAAOG,EAASsB,QAAQA,GAAUqB,GACrB,IAAnByC,EAAQ3H,OAEV,MADAkC,GAAK6B,QAAQF,GACO,WAAhBA,EAAQ6C,IAMhB,OAAO,GAUHgB,EAAiB,SAACvF,EAASH,GAC/B,GAAM2E,GAAUxE,EAAQwE,QAAQC,aAChC,IAAI5C,EAAYhC,EAAO0E,IAAK,KAAMC,GAChC,MAAO,KAET,IAAM9C,IAAU,EAAArB,EAAAiE,gBAEhB,OADA5C,GAAQ6C,IAAMC,EACP9C,GAWHF,EAAgB,SAACxB,EAASD,EAAV0F,GAGpB,IAAK,GAHiC5F,GAAa4F,EAAb5F,OAChCkD,EAAS/C,EAAQyB,WACjBiE,EAAW3C,EAAO2C,SACfnK,EAAI,EAAGC,EAAIkK,EAAS7H,OAAQtC,EAAIC,EAAGD,IAAK,CAC/C,GAAMoK,GAAQD,EAASnK,EACvB,IAAIoK,IAAU3F,EAAS,CACrB,GAAM4F,GAAeL,EAAeI,EAAO9F,EAC3C,OAAK+F,IAKLA,EAAaC,QAAU,QACvBD,EAAaE,QAAS,cAAcvK,EAAI,GAAlB,KACtBwE,EAAK6B,QAAQgE,IACN,GAPEG,QAAQC,KAAR,mFAEJL,EAAO9F,EAAQ+F,IAQxB,OAAO,GAcHrE,EAAY,SAACvB,EAASD,EAAVkG,EAA4BhG,EAAQG,EAAUX,GAAW,GAAvCI,GAAuCoG,EAAvCpG,OAC5B6B,EAAU6D,EAAevF,EAASH,EACxC,KAAK6B,EACH,OAAO,CAET,IAAMwE,GAAezG,EAASO,EAAQkG,YAAelG,EAAQmG,YAAcnG,EAAQmG,WAAWC,WAAc,EAC5G,KAAKF,EACH,OAAO,CAGTxE,GAAQmE,QAAU,OAUlB,KATA,GAAM9C,GAAS/C,EAAQyB,WACjB4E,EAAQH,EACX7H,QAAQ,OAAQ,MAChB6G,MAAM,MACN1E,IAAI,SAAA8F,GAAA,MAAQA,GAAKrB,SACjBzB,OAAO,SAAA8C,GAAA,MAAQA,GAAKzI,OAAS,IAE1B+E,KAECyD,EAAMxI,OAAS,GAAG,CACvB,GAAMyI,GAAOD,EAAM9C,OACnB,IAAI1B,EAAYhC,EAAO+C,SAAU,KAAM0D,EAAMvE,EAAca,UACzD,KAEFA,GAAShF,KAAT,aAA2B0I,EAA3B,KAEA,IAAMd,GAAUvF,EAAOG,EAASsB,QAATS,KAAsBT,GAASoE,OAAQlD,KAAaG,EAC3E,IAAuB,IAAnByC,EAAQ3H,OAGV,MAFA6D,GAAQoE,OAASlD,EACjB7C,EAAK6B,QAAQF,IACN,CAET,IAAuB,IAAnB8D,EAAQ3H,OACV,OAAO,EAGX,OAAO,GAaHyD,EAA4B,SAACtB,EAASD,EAAMR,EAASU,EAAQG,GACjE,GAAMsB,GAAU6D,EAAevF,EAAST,EAAQM,OAChD,KAAK6B,EACH,OAAO,CAIT,KADA,GAAM6E,GAAcxI,MAAMqB,KAAKY,EAAQwG,iBAAiB,MACjDD,EAAY1I,OAAS,GAAG,CAC7B,GAAM4I,GAAiBpH,EAAMkH,EAAYhD,QAAlBpB,KAAgC5C,GAAS3E,KAAMoF,KAAW,EAEjF,KAAKyG,EAAe9F,KAAK,SAAAe,GAAA,MAAWA,GAAQoE,OAAOnF,KAAK,SAAA/D,GAAA,MAAKA,GAAE8J,WAAW,iBAAgB,CACxF,GAAM3D,GAAS/C,EAAQ2G,aAEvB,IAAuB,IADP1G,EAAOG,EAASsB,QAATS,KAAsBT,GAAS6E,aAAcE,MAAoB1D,GAC5ElF,OAGV,MAFA6D,GAAQ6E,aAAeE,GACvB1G,EAAK6B,QAAQF,IACN,GAKb,OAAO,GAYHC,EAAc,SAAC3B,EAAD4G,EAAgC3G,EAAQG,GAAa,GAAzC0C,GAAyC8D,EAAzC9D,SAAUjD,EAA+B+G,EAA/B/G,OACpC6B,EAAUsB,EAAsBF,EAAU9C,EAASH,EAAQI,EAAQG,EAIvE,OAHKsB,KACHA,EAAU6D,EAAevF,EAASH,IAE7B6B,GAYIG,gBAAc,SAACrD,EAAW1C,EAAMF,EAAOiL,GAClD,IAAKjL,EACH,OAAO,CAET,IAAMkL,GAAQtI,GAAaqI,CAC3B,SAAKC,GAGEA,EAAMhL,EAAMF,EAAOiL,KHkPtB,SAAS9L,EAAQD,EAASM,GAEhC,YAGAa,QAAOC,eAAepB,EAAS,cAC7Bc,OAAO,IAETd,EAAQwF,YAAcxF,EAAQiM,mBAAqBjM,EAAQkM,YAAclM,EAAQmM,eAAiBnM,EAAQoM,cAAgBpM,EAAQqM,eAAiBrM,EAAQsM,kBAAoBtM,EAAQuM,eAAiBvM,EAAQwM,kBAAoBxM,EAAQyM,iBAAmBzM,EAAQ0M,kBAAoB1M,EAAQ2M,qBAAuB3M,EAAQwJ,kBAAgBjH,EAElV,IAAI8E,GAAWlG,OAAOmG,QAAU,SAAUC,GAAU,IAAK,GAAI9G,GAAI,EAAGA,EAAIiE,UAAU3B,OAAQtC,IAAK,CAAE,GAAI+G,GAAS9C,UAAUjE,EAAI,KAAK,GAAIgH,KAAOD,GAAcrG,OAAOS,UAAUC,eAAelB,KAAK6G,EAAQC,KAAQF,EAAOE,GAAOD,EAAOC,IAAY,MAAOF,IIlsBvPpB,EAAA7F,EAAA,GA0BaqM,GATAnD,gBAAgB,cAACT,GAADrE,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,YAAA2C,IACxB8B,cAAgBL,WAAakC,UAAYS,gBAAoB1C,IAQrD4D,uBAAuB,SAACxD,GAAD,MAClCA,GAAWzD,IAAI,SAAA9B,GAAqB,GAAlB5C,GAAkB4C,EAAlB5C,KAAMF,EAAY8C,EAAZ9C,KACtB,OAAc,QAAVA,EACF,IAAWE,EAAX,IAEW,OAATA,IAAiB,EAAAmF,EAAAjC,sBAAqBpD,GACxC,IAAWA,EAEb,IAAWE,EAAX,KAAoBF,EAApB,OACC8L,KAAK,MAQGF,sBAAoB,SAAC5D,GAAD,MAC/BA,GAAQpD,IAAI,SAAA7E,GAAA,OAAK,EAAAsF,EAAAjC,sBAAqBrD,GAArB,IAA8BA,EAA9B,YAAgDA,EAAhD,OAAuD+L,KAAK,KAQlEH,qBAAmB,SAACzB,GAAD,MAAYA,GAAOjI,OAAP,IAAoBiI,EAAO4B,KAAK,KAAS,IAQxEJ,sBAAoB,SAAC5F,GAAY,GACpCmE,GAA8CnE,EAA9CmE,QAAStB,EAAqC7C,EAArC6C,IAAKN,EAAgCvC,EAAhCuC,WAAYL,EAAoBlC,EAApBkC,QAASkC,EAAWpE,EAAXoE,MAY3C,QAVc,UAAZD,EAAsB,KAAO,KAE7BtB,GAAO,IAEPkD,EAAqBxD,GAErBuD,EAAkB5D,GAElB2D,EAAiBzB,IAWRuB,mBAAiB,SAACtH,GAAD,MAC5BA,GAAKS,IAAI8G,GAAmBI,KAAK,MAG7BC,EAAkB,SAAC/L,GAAD,MACtBA,IAASA,EAAMyC,QAAQ,wCAAyC,MAC7DA,QAAQ,YAAa,QACrBA,QAAQ,QAAS,OAQT+I,sBAAoB,SAACnD,GAAD,MAC/BA,GAAWzD,IAAI,SAAA5B,GAAqB,GAAlB9C,GAAkB8C,EAAlB9C,KAAMF,EAAYgD,EAAZhD,KACtB,OAAc,QAAVA,EACF,KAAYE,EAAZ,IAEF,KAAYA,EAAZ,KAAqB6L,EAAgB/L,GAArC,OACC8L,KAAK,KAQGP,mBAAiB,SAACvD,GAAD,MAC5BA,GAAQpD,IAAI,SAAA7E,GAAA,6DAA4DA,EAA5D,SAAqE+L,KAAK,KAQ3ER,kBAAgB,SAACpB,GAAD,MAC3BA,GAAOtF,IAAI,SAAA5D,GACT,GAAMyC,GAAQzC,EAAEyC,MAAM,6CACtB,KAAKA,EACH,MAAO,EAGT,QAAQA,EAAM,IACZ,IAAK,YACH,4CAA6CA,EAAM,GAAnD,GAEF,KAAK,cACH,UAAWA,EAAM,GAAjB,GAEF,KAAK,WACH,0BAA2BA,EAAM,GAAjC,IAEF,SACE,MAAO,MAEVqI,KAAK,KAQGT,mBAAiB,SAACvF,GAAY,GACjCmE,GAA2DnE,EAA3DmE,QAAStB,EAAkD7C,EAAlD6C,IAAKN,EAA6CvC,EAA7CuC,WAAYL,EAAiClC,EAAjCkC,QAASkC,EAAwBpE,EAAxBoE,OAAQS,EAAgB7E,EAAhB6E,WAcnD,QAZc,UAAZV,EAAsB,IAAM,OAE5BtB,GAAO,KAEP6C,EAAkBnD,GAElBkD,EAAevD,GAEfsD,EAAcpB,GAEdiB,EAAmBR,IAWVS,gBAAc,SAACjH,GAAD,UAAcA,EAAKS,IAAIyG,GAAgBS,KAAK,KAQ1DX,uBAAqB,SAACrB,GAAD,MAChCA,GAAS7H,OAAT,IAAsB6H,EAASlF,IAAIwG,GAAaU,KAAK,MAArD,IAAgE,IAG5DtH,GACJwH,KACE3D,WAAYwD,EACZ7D,QAAS4D,EACT1B,OAAQyB,EACR7F,QAAS4F,EACTvH,KAAMsH,GAERQ,OACE5D,WAAYmD,EACZxD,QAASuD,EACTrB,OAAQoB,EACRxF,QAASuF,EACTlH,KAAMiH,GAERc,UAGF1H,GAAS0H,OAAS1H,EAASwH,IAC3BxH,EAAS,GAAKA,EAASwH,IACvBxH,EAAS,GAAKA,EAASyH,KAgBVvH,eAAc,cAACf,GAADC,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,YACzBY,GAASb,EAAQO,QAAU,SJotBvB,SAAS/E,EAAQD,EAASM,GAEhC,YAGAa,QAAOC,eAAepB,EAAS,cAC7Bc,OAAO,GKt7BT,IAAImM,UAQEC,EAAe,SAACC,GAA4B,GAAlBlF,GAAkBvD,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,GAAT,IAIvC,OAHKuI,KACHA,EAAS3M,EAAQ,IAEZ2M,EAAOE,EAAUlF,GAAUF,WAS9BqF,EAAc,SAACD,GAA4B,GAAlBlF,GAAkBvD,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,GAAT,IACtCuD,GAAUA,GAAUF,QAEpB,KADA,GAAIsF,GAAMpF,EACHoF,EAAI1G,YACT0G,EAAMA,EAAI1G,UAER0G,KAAQpF,GAAWkF,EAASvB,WAAW,OACzCuB,MAAeA,EAKjB,KAHA,GAEIjI,GAFAvC,EAAW0K,EAAIC,SAASH,EAAUlF,EAAQ,KAAM,GAChDsF,KAEIrI,EAAUvC,EAAS6K,eACzBD,EAASzK,KAAKoC,EAEhB,OAAOqI,IASHE,EAAY,SAACN,GAAD,QAAAzI,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,GAAoB,OACzBqD,UAAU2D,iBAAiByB,IAElChI,GACJ2H,IAAOW,EACPV,MAASK,EACTJ,OAAUE,EAGZ/H,GAAO,GAAKA,EAAO2H,IACnB3H,EAAO,GAAKA,EAAO4H,KAON1H,aAAY,cAACZ,GAADC,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,YACvB,UAACyI,EAAUlF,GACT,IACE,MAAO9C,GAAOV,EAAQO,QAAU,OAAOmI,EAAUlF,GAAUxD,EAAQ3E,MACnE,MAAOkD,GACP,aLu8BA,SAAS/C,EAAQD,EAASM,GAEhC,YAGAa,QAAOC,eAAepB,EAAS,cAC7Bc,OAAO,IAETd,EAAQ0N,oBAAsB1N,EAAQ2N,sBAAoBpL,EMlgC1D,IAAAqL,GAAAtN,EAAA,GACA6F,EAAA7F,EAAA,EAEaqN,qBAAoB,SAACJ,GAA2B,GAAjB9I,GAAiBC,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,MAAAmJ,EAIvDpJ,EADF3E,WAHyDyC,KAAAsL,EAGlD9F,SAHkD8F,EAMrDC,IAENP,GAASvH,QAAQ,SAACd,EAAS6I,GAEzB,IADA,GAAMC,MACC9I,IAAYpF,GACjBoF,EAAUA,EAAQyB,WAClBqH,EAAQlH,QAAQ5B,EAElB4I,GAAUC,GAASC,IAGrBF,EAAUG,KAAK,SAACC,EAAMtL,GAAP,MAAgBsL,GAAKnL,OAASH,EAAKG,QAMlD,KAAK,GAJCoL,GAAkBL,EAAUrF,QAE9B2F,EAAW,KArB4CC,EAAA,WAwBzD,GAAMpG,GAASkG,EAAgB1N,EAK/B,IAJgBqN,EAAUjI,KAAK,SAACyI,GAC9B,OAAQA,EAAazI,KAAK,SAAC0I,GAAD,MAAiBA,KAAgBtG,MAK3D,aAGFmG,GAAWnG,GAXJxH,EAAI,EAAGC,EAAIyN,EAAgBpL,OAAQtC,EAAIC,EAAGD,IAAK,cAAA4N,IAQpD,MAMJ,MAAOD,IASIV,sBAAsB,SAACH,GAA2B,GAAjB9I,GAAiBC,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,MAAA8J,EACrC/J,EAAhBM,aADqDxC,KAAAiM,OAGvDC,GACJ3F,WACAK,cACAM,IAAK,KAmFP,OAhFA8D,GAASvH,QAAQ,SAACd,GAAY,GAGjBwJ,GAGPD,EAHF3F,QACY6F,EAEVF,EAFFtF,WACKyF,EACHH,EADFhF,GAIF,QAAsBlH,KAAlBmM,EAA6B,CAC/B,GAAI5F,GAAU5D,EAAQ2J,aAAa,QAC/B/F,IACFA,EAAUA,EAAQqB,OAAOC,MAAM,KAAK1B,OAAO,SAAAoG,GAAA,OAAQ/J,EAAOuF,QAAUvF,EAAOuF,MAAMwE,KAC5EJ,EAAc3L,QAGjB2L,EAAgBA,EAAchG,OAAO,SAAC/C,GAAD,MAAWmD,GAAQjD,KAAK,SAAC7E,GAAD,MAAUA,KAAS2E,MAC5E+I,EAAc3L,OAChB0L,EAAiB3F,QAAU4F,QAEpBD,GAAiB3F,SAN1B2F,EAAiB3F,QAAUA,SAUtB2F,GAAiB3F,QAK5B,OAAyBvG,KAArBoM,EAAgC,CAClC,GAAMI,GAAoB7J,EAAQiE,WAC5BA,EAAahI,OAAO4E,KAAKgJ,GAAmBpL,OAAO,SAACwF,EAAY1B,GACpE,GAAME,GAAYoH,EAAkBtH,GAC9BG,GAAgB,EAAAzB,EAAA7C,aAAYqE,GAAaA,EAAU3G,MACnD6I,GAAiB,EAAA1D,EAAA7C,aAAYqE,GAAaA,EAAU7G,OACpDgJ,EAAmC,UAAlBlC,EACjBmC,EAAiBD,GAAkB/E,EAAO6C,IAAmB7C,EAAO4C,UACpEqC,EAAwBF,GAAkB7C,gBAAcW,IAAmBX,gBAAcU,SAI/F,OAHIA,IAA+B,UAAlBC,KAA8B,EAAAgG,EAAA7G,aAAYgD,EAAenC,EAAeiC,EAAgBG,KACvGb,EAAWvB,GAAiBD,EAAU7G,OAEjCqI,OAGH6F,EAAkB7N,OAAO4E,KAAKoD,GAC9B8F,EAAwB9N,OAAO4E,KAAK4I,EAEtCK,GAAgBjM,OACbkM,EAAsBlM,QAGzB4L,EAAmBM,EAAsBtL,OAAO,SAACuL,EAAsBlO,GACrE,GAAMF,GAAQ6N,EAAiB3N,EAI/B,OAHIF,KAAUqI,EAAWnI,KACvBkO,EAAqBlO,GAAQF,GAExBoO,OAEL/N,OAAO4E,KAAK4I,GAAkB5L,OAChC0L,EAAiBtF,WAAawF,QAEvBF,GAAiBtF,YAZ1BsF,EAAiBtF,WAAaA,QAgBzBsF,GAAiBtF,WAK5B,OAAkB5G,KAAdqM,EAAyB,CAC3B,GAAMnF,GAAMvE,EAAQwE,QAAQC,aACvBiF,GAEMnF,IAAQmF,SACVH,GAAiBhF,IAFxBgF,EAAiBhF,IAAMA,KAOtBgF,IN4iCH,SAASxO,EAAQD,EAASM,GAEhC,YAoBA,SAAS8D,GAAmBlC,GAAO,GAAIe,MAAMC,QAAQhB,GAAM,CAAE,IAAK,GAAIzB,GAAI,EAAG4D,EAAOpB,MAAMf,EAAIa,QAAStC,EAAIyB,EAAIa,OAAQtC,IAAO4D,EAAK5D,GAAKyB,EAAIzB,EAAM,OAAO4D,GAAe,MAAOpB,OAAMqB,KAAKpC,GOpsC3K,QAASiN,GAAUlK,EAAMsI,GAAwB,GAAd9I,GAAcC,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,KAC9D,IAAoB,IAAhBO,EAAKlC,OACP,QAYF,IATwB,UAApBkC,EAAK,GAAG8F,UACV9F,EAAK,GAAG8F,YAAUxI,IAIfU,MAAMC,QAAQqK,KACjBA,EAAYA,EAASxK,QAAsB,EAAAoD,EAAA/C,iBAAgBmK,IAA5BA,KAG5BA,EAASxK,QAAUwK,EAAS1H,KAAK,SAACX,GAAD,MAAkC,KAArBA,EAAQkB,WACzD,KAAM,IAAIgJ,OAAM,6HAGlB,IAAMjK,IAAS,EAAAC,EAAAC,WAAUZ,GACnBa,GAAW,EAAA+J,EAAA7J,aAAYf,EAE7B,IAAoB,IAAhBQ,EAAKlC,OACP,OAAQuM,KAAiBrK,EAAK,MAAQsI,EAAUpI,EAAQG,GAG1D,IAAIiK,IAAe,CACiB,WAAhCtK,EAAKA,EAAKlC,OAAO,GAAGgI,UACtB9F,EAAKA,EAAKlC,OAAO,GAAKuM,EAAarK,EAAKuK,MAAM,GAAI,GAAIvK,EAAKA,EAAKlC,OAAO,MAAQwK,EAAUpI,EAAQG,GACjGiK,GAAe,GAGjBtK,cAAWA,GAEX,KADA,GAAMwK,IAAaxK,EAAKyK,OAhCsCrB,EAAA,WAkC5D,GAAMsB,GAAU1K,EAAKyK,MACfhF,EAAUvF,EAAOG,EAASL,QAAThB,OAAAG,EAAkBa,GAASwK,IAC5B/E,GAAQ3H,SAAWwK,EAASxK,QAAUwK,EAASqC,MAAM,SAAC1K,EAASzE,GAAV,MAAgByE,KAAYwF,EAAQjK,MAE7GgP,EAAU3I,QAAQwI,EAAarK,EAAM0K,EAASF,EAAWlC,EAAUpI,EAAQG,KALxEL,EAAKlC,OAAS,GAAGsL,GAiBxB,OATAoB,GAAU3I,QAAQ7B,EAAK,IACvBA,EAAOwK,EAGPxK,EAAK,GAAKqK,KAAiBrK,EAAK,GAAIA,EAAKuK,MAAM,GAAIjC,EAAUpI,EAAQG,GAChEiK,IACHtK,EAAKA,EAAKlC,OAAO,GAAKuM,EAAarK,EAAKuK,MAAM,GAAI,GAAIvK,EAAKA,EAAKlC,OAAO,MAAQwK,EAAUpI,EAAQG,IAG5FL,EPioCT9D,OAAOC,eAAepB,EAAS,cAC7Bc,OAAO,IAETd,EAAQ6P,mBAAiBtN,EAEzB,IAAI8E,GAAWlG,OAAOmG,QAAU,SAAUC,GAAU,IAAK,GAAI9G,GAAI,EAAGA,EAAIiE,UAAU3B,OAAQtC,IAAK,CAAE,GAAI+G,GAAS9C,UAAUjE,EAAI,KAAK,GAAIgH,KAAOD,GAAcrG,OAAOS,UAAUC,eAAelB,KAAK6G,EAAQC,KAAQF,EAAOE,GAAOD,EAAOC,IAAY,MAAOF,IAEnPvF,EAAiB,WAAc,QAASC,GAAcC,EAAKzB,GAAK,GAAI0B,MAAeC,GAAK,EAAUC,GAAK,EAAWC,MAAKC,EAAW,KAAM,IAAK,GAAiCC,GAA7BC,EAAKP,EAAIQ,OAAOC,cAAmBP,GAAMI,EAAKC,EAAGG,QAAQC,QAAoBV,EAAKW,KAAKN,EAAG1B,QAAYL,GAAK0B,EAAKY,SAAWtC,GAA3D2B,GAAK,IAAoE,MAAOY,GAAOX,GAAK,EAAMC,EAAKU,EAAO,QAAU,KAAWZ,GAAMK,EAAW,QAAGA,EAAW,SAAO,QAAU,GAAIJ,EAAI,KAAMC,IAAQ,MAAOH,GAAQ,MAAO,UAAUD,EAAKzB,GAAK,GAAIwC,MAAMC,QAAQhB,GAAQ,MAAOA,EAAY,IAAIQ,OAAOC,WAAYxB,QAAOe,GAAQ,MAAOD,GAAcC,EAAKzB,EAAa,MAAM,IAAI0C,WAAU,2DAEtlBnD,GAAQ0H,QO5rCgByH,CAlBxB,IAAA/J,GAAA9E,EAAA,GACA+O,EAAA/O,EAAA,GACA6F,EAAA7F,EAAA,GAgFMwP,EAAe,SAACC,EAAKJ,EAASK,EAAMzC,EAAUpI,EAAQG,GAAa,GAAA2K,IAC7C,EAAA9J,EAAA3C,WAAUmM,EAAQ3E,OAAQ,SAACnH,GAAD,MAAUA,GAAK+H,WAAW,cADPsE,EAAAlO,EAAAiO,EAAA,GAChEnI,EADgEoI,EAAA,GACtDC,EADsDD,EAAA,EAGvE,IAAIpI,EAAS/E,OAAS,GAAKiN,EAAKjN,OAAQ,CAEtC,IADA,GAAMgG,QAAY4G,GAAS3E,mBAAYmF,GAAZ/L,EAAsB0D,MAC1CiB,EAAKiC,OAAOjI,OAASoN,EAAMpN,QAAQ,CACxC,GAAMqN,GAAYrH,EAAKiC,OAAOwE,MAAM,GAAI,EACxC,KAAKK,EAAe1K,EAAOG,EAASL,QAAThB,OAAAG,EAAkB2L,IAAlB1I,KAA4B0B,GAAMiC,OAAQoF,KAA1ChM,EAA0D4L,MAASzC,GAC5F,KAEFxE,GAAKiC,OAASoF,EAEhB,MAAOrH,GAET,MAAO4G,IAcHU,EAAqB,SAACN,EAAKJ,EAASK,EAAMzC,EAAUpI,EAAQG,GAEhE,GAAIqK,EAAQxG,WAAWpG,OAAS,EAAG,CACjC,GAAIoG,eAAiBwG,EAAQxG,aAEvBmH,EAAW,SAACC,EAAUC,GAE1B,IADA,GAAI/P,GAAI8P,EAASxN,OAAS,EACnBtC,GAAK,GAAG,CACb,GAAI0I,GAAaqH,EAAcD,EAAU9P,EACzC,KAAKoP,EACH1K,EAAOG,EAASL,QAAThB,OAAAG,EAAkB2L,IAAlB1I,KAA4BsI,GAASxG,gBAArC/E,EAAsD4L,MAC7DzC,GAEA,KAEF9M,KACA8P,EAAWpH,EAEb,MAAOoH,IAGHE,EAAaH,EAASnH,EAAY,SAACA,EAAY1I,GAAM,GACjDO,GAASmI,EAAW1I,GAApBO,IACR,OAAa,OAATA,EACKmI,KAETlF,OAAAG,EAAW+E,EAAWqG,MAAM,EAAG/O,MAAMO,OAAMF,MAAO,OAAlDsD,EAA6D+E,EAAWqG,MAAM/O,EAAI,MAEpF,OAAA4G,MAAYsI,GAASxG,WAAYmH,EAASG,EAAY,SAAAtH,GAAA,MAAcA,GAAWqG,MAAM,GAAI,OAE3F,MAAOG,IAcHe,EAAqB,SAACX,EAAKJ,EAASK,EAAMzC,EAAUpI,EAAQG,GAEhE,GAAwB,UAApBqK,EAAQ5E,QAAqB,CAC/B,GAAM4F,QAAkBhB,GAAS5E,YAASxI,KACtCmI,EAAUvF,EAAOG,EAASL,QAAThB,OAAAG,EAAkB2L,IAAKY,GAAvBvM,EAAsC4L,KAC3D,IAAIH,EAAenF,EAAS6C,GAC1B,MAAOoD,GAGX,MAAOhB,IAcHiB,EAA+B,SAACb,EAAKJ,EAASK,EAAMzC,EAAUpI,EAAQG,GAC1E,GAAIqK,EAAQlE,YAAY1I,OAAS,GAAKiN,EAAKjN,OAAQ,CAEjD,IADA,GAAMgG,QAAY4G,GAASlE,wBAAiBkE,EAAQlE,gBAC7C1C,EAAK0C,YAAY1I,OAAS,GAAG,CAClC,GAAMqN,GAAYrH,EAAK0C,YAAY+D,MAAM,GAAI,EAC7C,KAAKK,EAAe1K,EAAOG,EAASL,QAAThB,OAAAG,EAAkB2L,IAAlB1I,KAA4B0B,GAAM0C,YAAa2E,KAA/ChM,EAA+D4L,MAASzC,GACjG,KAEFxE,GAAK0C,YAAc2E,EAErB,MAAOrH,GAET,MAAO4G,IAcHkB,EAAoB,SAACd,EAAKJ,EAASK,EAAMzC,EAAUpI,EAAQG,GAC/D,GAAM7E,GAAIkP,EAAQ3E,OAAO8F,UAAU,SAAAjN,GAAA,MAAQA,GAAK+H,WAAW,cAE3D,IAAInL,GAAK,EAAG,CAEV,GAAMwF,GAAO0J,EAAQ3E,OAAOvK,GAAG8C,QAAQ,aAAc,eAC/CwN,OAAiBpB,GAAS3E,mBAAY2E,EAAQ3E,OAAOwE,MAAM,EAAG/O,KAAIwF,GAAxC7B,EAAiDuL,EAAQ3E,OAAOwE,MAAM/O,EAAI,OACtGmG,EAAUtB,EAASL,QAAThB,OAAAG,EAAkB2L,IAAKgB,GAAvB3M,EAAqC4L,KAC/CtF,EAAUvF,EAAOyB,EACrB,IAAIiJ,EAAenF,EAAS6C,GAC1B,MAAOwD,GAGX,MAAOpB,IAcHqB,EAAkB,SAACjB,EAAKJ,EAASK,EAAMzC,EAAUpI,EAAQG,GAE7D,GAAIqK,EAAQ7G,QAAQ/F,OAAS,EAAG,CAG9B,IAFA,GAAIqN,GAAYT,EAAQ7G,QAAQ0G,QAAQvB,KAAK,SAACC,EAAMtL,GAAP,MAAgBsL,GAAKnL,OAASH,EAAKG,SAEzEqN,EAAUrN,OAAS,GAAG,CAC3BqN,EAAU3H,OACV,IAAM7B,GAAUtB,EAASL,QAAThB,OAAAG,EAAkB2L,IAAlB1I,KAA4BsI,GAAS7G,QAASsH,KAA9ChM,EAA8D4L,IAC9E,KAAKH,EAAe1K,EAAOyB,GAAU2G,GACnC,KAEFoC,GAAQ7G,QAAUsH,EAKpB,GAFAA,EAAYT,EAAQ7G,QAEhBsH,EAAUrN,OAAS,EAGrB,IAAK,GAFCgG,IAAO,EAAAsG,EAAA7F,gBAAgBV,QAASsH,IAChCa,EAAa9L,EAAOG,EAASL,QAAThB,OAAAG,EAAkB2L,IAAKhH,MAFzBmI,EAAA,WAItB,GAAMC,GAAYF,EAAWxQ,EAC7B,IAAI8M,EAAS1H,KAAK,SAACX,GAAD,MAAaiM,GAAUrJ,SAAS5C,KAAW,CAG3D,GAAMkM,IAAc,EAAA/B,EAAA7F,gBAAgBC,IAAK0H,EAAUzH,SAMnD,OALI9C,GAAUtB,EAASL,QAAThB,OAAAG,EAAkB2L,IAAKqB,GAAvBhN,EAAuC4L,KACjDtF,EAAUvF,EAAOyB,GACjBiJ,EAAenF,EAAS6C,KAC1BoC,EAAUyB,GAEZ,UAXK3Q,EAAI,EAAGA,EAAIwQ,EAAWlO,OAAQtC,IAAK,IAMpCmG,GACA8D,EAPoC2G,EAAAH,GAAA,cAAAG,EAWxC,OAKR,MAAO1B,IAGH2B,GACJxB,EACAO,EACAK,EACAE,EACAC,EACAG,GAcI1B,EAAe,SAACS,EAAKJ,EAASK,EAAMzC,EAAUpI,EAAQG,GAAvC,MACnBgM,GAAW3N,OAAO,SAAC4N,EAAKC,GAAN,MAAoBA,GAAUzB,EAAKwB,EAAKvB,EAAMzC,EAAUpI,EAAQG,IAAWqK,IASlFE,mBAAiB,SAACnF,EAAS6C,GAAa,GAC3CxK,GAAW2H,EAAX3H,MACR,OAAOA,KAAWwK,EAASxK,QAAUwK,EAASqC,MAAM,SAAC1K,GACnD,IAAK,GAAIzE,GAAI,EAAGA,EAAIsC,EAAQtC,IAC1B,GAAIiK,EAAQjK,KAAOyE,EACjB,OAAO,CAGX,QAAO,MP6vCL,SAASjF,EAAQD,EAASM,GAEhC,YAkCA,SAASmR,GAAuBtK,GAAO,MAAOA,IAAOA,EAAI1F,WAAa0F,GAAQO,QAASP,GAEvF,QAAS/C,GAAmBlC,GAAO,GAAIe,MAAMC,QAAQhB,GAAM,CAAE,IAAK,GAAIzB,GAAI,EAAG4D,EAAOpB,MAAMf,EAAIa,QAAStC,EAAIyB,EAAIa,OAAQtC,IAAO4D,EAAK5D,GAAKyB,EAAIzB,EAAM,OAAO4D,GAAe,MAAOpB,OAAMqB,KAAKpC,GQ59C3K,QAASwP,GAAiBC,GAAqB,GAAdlN,GAAcC,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,MACtDO,EAAQ0M,EAAM5O,SAAW4O,EAAM3Q,KACjC4Q,EAAqBD,EAAOlN,GAC5BoN,EAAsBF,EAAOlN,EAEjC,OAAIxB,OAAMC,QAAQ+B,IAASA,EAAKlC,OAAS,GAAKkC,EAAK,YAAc6M,aACxD7M,EAAKS,IAAI,SAAAC,GAAA,MAAS+L,GAAiB/L,EAAOlB,KAAUmI,KAAK,MAE3D,EAAArH,EAAAC,aAAYf,GAASQ,KAAKA,GRm7CnC9D,OAAOC,eAAepB,EAAS,cAC7Bc,OAAO,IAETd,EAAQ4R,qBAAuB5R,EAAQ6R,0BAAwBtP,EAE/D,IAAI2E,GAA4B,kBAAXxE,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUwE,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXzE,SAAyByE,EAAIC,cAAgB1E,QAAUyE,IAAQzE,OAAOd,UAAY,eAAkBuF,GAQtQnH,GAAQ0H,QQx8CgBgK,CA1HxB,IAAA9D,GAAAtN,EAAA,GRskDIyR,EAAUN,EAAuB7D,GQrkDrCoE,EAAA1R,EAAA,GRykDI2R,EAAaR,EAAuBO,GQxkDxC7L,EAAA7F,EAAA,GACA4R,EAAA5R,EAAA,GACA8E,EAAA9E,EAAA,GACAiF,EAAAjF,EAAA,GAsBauR,0BAAwB,SAAC3M,GAA0B,GAAjBT,GAAiBC,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,KAM9D,IAJyB,IAArBQ,EAAQkB,WACVlB,EAAUA,EAAQyB,YAGK,IAArBzB,EAAQkB,SACV,KAAM,IAAIgJ,OAAJ,+FAAsGlK,EAAtG,YAAAgC,EAAsGhC,IAAtG,KAGR,IAAMD,IAAO,EAAA8M,EAAArK,SAAMxC,EAAST,EAS5B,QARsB,EAAAwN,EAAAvK,SAASzC,EAAMC,EAAST,IAkBnCmN,yBAAuB,SAACrE,GAA2B,GAAjB9I,GAAiBC,UAAA3B,OAAA,OAAAR,KAAAmC,UAAA,GAAAA,UAAA,KAM9D,IAJKzB,MAAMC,QAAQqK,KACjBA,GAAW,EAAApH,EAAA/C,iBAAgBmK,IAGzBA,EAAS1H,KAAK,SAACX,GAAD,MAAkC,KAArBA,EAAQkB,WACrC,KAAM,IAAIgJ,OAAM,yFAGlB,IAAMjK,IAAS,EAAAC,EAAAC,WAAUZ,GACnBa,GAAW,EAAAC,EAAAC,aAAYf,GAEvB2J,GAAW,EAAA8D,EAAAvE,mBAAkBJ,EAAU9I,GACvC0N,GAAe,EAAAJ,EAAArK,SAAM0G,EAAU3J,GAG/B2N,EAAaC,EAAc9E,EAAU9I,GACrC6N,EAAoBF,EAAW,GAE/BG,GAAe,EAAAN,EAAAvK,YAAAzD,OAAAG,EAAa+N,IAAcG,IAAoB/E,EAAU9I,GACxE+N,GAAkB,EAAArM,EAAA/C,iBAAgB+B,EAAOG,EAASL,KAAKsN,IAE7D,OAAKhF,GAASqC,MAAM,SAAC1K,GAAD,MAAasN,GAAgB3M,KAAK,SAACF,GAAD,MAAWA,KAAUT,MASpEqN,GAPLtH,QAAQC,KAAR,uIAIOqC,IAYL8E,EAAgB,SAAC9E,EAAU9I,GAAY,GAAAgO,IACN,EAAAP,EAAAxE,qBAAoBH,EAAU9I,GAA3DqE,EADmC2J,EACnC3J,QAASK,EAD0BsJ,EAC1BtJ,WAAYM,EADcgJ,EACdhJ,GAG7B,SACE,EAAAlE,EAAAiE,gBACEC,MACAX,QAASA,MACTK,WAAYA,EAAahI,OAAO4E,KAAKoD,GAAYzD,IAAI,SAAC1E,GAAD,OACnDA,MAAM,EAAAmF,EAAA7C,aAAYtC,GAClBF,OAAO,EAAAqF,EAAA7C,aAAY6F,EAAWnI,eRwnDhC,SAASf,EAAQD,EAASM,GAEhC,YACA,IAAIoS,ISluDJ,SAAYC,GAiOZ,QAAS1F,GAAQE,EAAUyF,EAASC,EAASC,GAC5C,GAAIlS,GAAGH,EAAGsS,EAAMC,EAAKzO,EAAO0O,EAAQC,EACnCC,EAAaP,GAAWA,EAAQQ,cAGhChN,EAAWwM,EAAUA,EAAQxM,SAAW,CAKzC,IAHAyM,EAAUA,MAGe,gBAAb1F,KAA0BA,GACxB,IAAb/G,GAA+B,IAAbA,GAA+B,KAAbA,EAEpC,MAAOyM,EAIR,KAAMC,IACLO,EAAaT,GACbA,EAAUA,GAAW7K,EAEhBuL,GAAiB,CAIrB,GAAkB,KAAblN,IAAqB7B,EAAQgP,GAAWC,KAAMrG,IAGlD,GAAOvM,EAAI2D,EAAO,IAGjB,GAAkB,IAAb6B,EAAiB,CACrB,KAAO2M,EAAOH,EAAQa,eAAgB7S,IAUrC,MAAOiS,EALP,IAAKE,EAAKW,KAAO9S,EAEhB,MADAiS,GAAQ/P,KAAMiQ,GACPF,MAYT,IAAKM,IAAgBJ,EAAOI,EAAWM,eAAgB7S,KACtDkH,EAAU8K,EAASG,IACnBA,EAAKW,KAAO9S,EAGZ,MADAiS,GAAQ/P,KAAMiQ,GACPF,MAKH,IAAKtO,EAAO,GAElB,MADAzB,IAAK6Q,MAAOd,EAASD,EAAQgB,qBAAsBzG,IAC5C0F,CAGD,KAAOjS,EAAI2D,EAAO,KAASsP,EAAQC,wBACzClB,EAAQkB,uBAGR,MADAhR,IAAK6Q,MAAOd,EAASD,EAAQkB,uBAAwBlT,IAC9CiS,EAKT,GAAKgB,EAAQE,MACXC,EAAwB7G,EAAW,QACjC8G,IAAcA,EAAU9P,KAAMgJ,MAIlB,IAAb/G,GAAqD,WAAnCwM,EAAQsB,SAASvK,eAA+B,CAYpE,GAVAuJ,EAAc/F,EACdgG,EAAaP,EASK,IAAbxM,IACF+N,GAAShQ,KAAMgJ,IAAciH,GAAajQ,KAAMgJ,IAAe,CAqBjE,IAlBAgG,EAAakB,GAASlQ,KAAMgJ,IAAcmH,EAAa1B,EAAQjM,aAC9DiM,EAIIO,IAAeP,GAAYiB,EAAQU,SAGhCvB,EAAMJ,EAAQ/D,aAAc,OAClCmE,EAAMA,EAAIzP,QAASiR,GAAYC,IAE/B7B,EAAQ8B,aAAc,KAAQ1B,EAAM2B,IAKtC1B,EAAS2B,EAAUzH,GACnB1M,EAAIwS,EAAOlQ,OACHtC,KACPwS,EAAQxS,IAAQuS,EAAM,IAAMA,EAAM,UAAa,IAC9C6B,EAAY5B,EAAQxS,GAEtByS,GAAcD,EAAOrG,KAAM,KAG5B,IAIC,MAHA9J,IAAK6Q,MAAOd,EACXM,EAAWzH,iBAAkBwH,IAEvBL,EACN,MAAQiC,GACTd,EAAwB7G,GAAU,GANnC,QAQM6F,IAAQ2B,GACZ/B,EAAQmC,gBAAiB,QAQ9B,MAAO5P,GAAQgI,EAAS5J,QAASyR,GAAO,MAAQpC,EAASC,EAASC,GASnE,QAASmC,KAGR,QAASC,GAAOzN,EAAK3G,GAQpB,MALKiF,GAAKjD,KAAM2E,EAAM,KAAQ0N,EAAKC,mBAG3BF,GAAOnP,EAAK0C,SAEXyM,EAAOzN,EAAM,KAAQ3G,EAV/B,GAAIiF,KAYJ,OAAOmP,GAOR,QAASG,GAAcC,GAEtB,MADAA,GAAIX,IAAY,EACTW,EAOR,QAASC,GAAQD,GAChB,GAAIE,GAAKzN,EAAS0N,cAAe,WAEjC,KACC,QAASH,EAAIE,GACZ,MAAQE,GACT,OAAO,EAHR,QAOMF,EAAG7O,YACP6O,EAAG7O,WAAWgP,YAAaH,GAI5BA,EAAK,MASP,QAASI,GAAWC,EAAOC,GAI1B,IAHA,GAAI5T,GAAM2T,EAAMzL,MAAO,KACtB3J,EAAIyB,EAAIa,OAEDtC,KACP0U,EAAKY,WAAY7T,EAAKzB,IAAQqV,EAUhC,QAASE,GAAc1M,EAAG2M,GACzB,GAAIC,GAAMD,GAAK3M,EACd6M,EAAOD,GAAsB,IAAf5M,EAAElD,UAAiC,IAAf6P,EAAE7P,UACnCkD,EAAE8M,YAAcH,EAAEG,WAGpB,IAAKD,EACJ,MAAOA,EAIR,IAAKD,EACJ,KAAUA,EAAMA,EAAIG,aACnB,GAAKH,IAAQD,EACZ,OAAQ,CAKX,OAAO3M,GAAI,GAAK,EAOjB,QAASgN,GAAmBrQ,GAC3B,MAAO,UAAU8M,GAEhB,MAAgB,UADLA,EAAKmB,SAASvK,eACEoJ,EAAK9M,OAASA,GAQ3C,QAASsQ,GAAoBtQ,GAC5B,MAAO,UAAU8M,GAChB,GAAI/R,GAAO+R,EAAKmB,SAASvK,aACzB,QAAkB,UAAT3I,GAA6B,WAATA,IAAuB+R,EAAK9M,OAASA,GAQpE,QAASuQ,GAAsBC,GAG9B,MAAO,UAAU1D,GAKhB,MAAK,QAAUA,GASTA,EAAKpM,aAAgC,IAAlBoM,EAAK0D,SAGvB,SAAW1D,GACV,SAAWA,GAAKpM,WACboM,EAAKpM,WAAW8P,WAAaA,EAE7B1D,EAAK0D,WAAaA,EAMpB1D,EAAK2D,aAAeD,GAI1B1D,EAAK2D,cAAgBD,GACrBE,GAAoB5D,KAAW0D,EAG1B1D,EAAK0D,WAAaA,EAKd,SAAW1D,IACfA,EAAK0D,WAAaA,GAY5B,QAASG,GAAwBtB,GAChC,MAAOD,GAAc,SAAUwB,GAE9B,MADAA,IAAYA,EACLxB,EAAc,SAAUvC,EAAMpI,GAMpC,IALA,GAAIoM,GACHC,EAAezB,KAAQxC,EAAK/P,OAAQ8T,GACpCpW,EAAIsW,EAAahU,OAGVtC,KACFqS,EAAQgE,EAAIC,EAActW,MAC9BqS,EAAMgE,KAASpM,EAASoM,GAAMhE,EAAMgE,SAYzC,QAASxC,GAAa1B,GACrB,MAAOA,QAAmD,KAAjCA,EAAQgB,sBAAwChB,EA0rC1E,QAASoE,MA0ET,QAASnC,GAAYoC,GAIpB,IAHA,GAAIxW,GAAI,EACPyW,EAAMD,EAAOlU,OACboK,EAAW,GACJ1M,EAAIyW,EAAKzW,IAChB0M,GAAY8J,EAAQxW,GAAIK,KAEzB,OAAOqM,GAGR,QAASgK,GAAeC,EAASC,EAAYtO,GAC5C,GAAIuO,GAAMD,EAAWC,IACpBxS,EAAOuS,EAAWzU,KAClB6E,EAAM3C,GAAQwS,EACdC,EAAmBxO,GAAgB,eAARtB,EAC3B+P,EAAW3U,GAEZ,OAAOwU,GAAWI,MAGjB,SAAU1E,EAAMH,EAAS8E,GACxB,KAAU3E,EAAOA,EAAMuE,IACtB,GAAuB,IAAlBvE,EAAK3M,UAAkBmR,EAC3B,MAAOH,GAASrE,EAAMH,EAAS8E,EAGjC,QAAO,GAIR,SAAU3E,EAAMH,EAAS8E,GACxB,GAAIC,GAAUC,EAAaC,EAC1BC,GAAaC,EAASP,EAGvB,IAAKE,GACJ,KAAU3E,EAAOA,EAAMuE,IACtB,IAAuB,IAAlBvE,EAAK3M,UAAkBmR,IACtBH,EAASrE,EAAMH,EAAS8E,GAC5B,OAAO,MAKV,MAAU3E,EAAOA,EAAMuE,IACtB,GAAuB,IAAlBvE,EAAK3M,UAAkBmR,EAQ3B,GAPAM,EAAa9E,EAAM4B,KAAe5B,EAAM4B,OAIxCiD,EAAcC,EAAY9E,EAAKiF,YAC5BH,EAAY9E,EAAKiF,cAEflT,GAAQA,IAASiO,EAAKmB,SAASvK,cACnCoJ,EAAOA,EAAMuE,IAASvE,MAChB,KAAO4E,EAAWC,EAAanQ,KACrCkQ,EAAU,KAAQI,GAAWJ,EAAU,KAAQH,EAG/C,MAASM,GAAU,GAAMH,EAAU,EAOnC,IAHAC,EAAanQ,GAAQqQ,EAGdA,EAAU,GAAMV,EAASrE,EAAMH,EAAS8E,GAC9C,OAAO,EAMZ,OAAO,GAIV,QAASO,GAAgBC,GACxB,MAAOA,GAASnV,OAAS,EACxB,SAAUgQ,EAAMH,EAAS8E,GAExB,IADA,GAAIjX,GAAIyX,EAASnV,OACTtC,KACP,IAAMyX,EAAUzX,GAAKsS,EAAMH,EAAS8E,GACnC,OAAO,CAGT,QAAO,GAERQ,EAAU,GAGZ,QAASC,GAAkBhL,EAAUiL,EAAUvF,GAG9C,IAFA,GAAIpS,GAAI,EACPyW,EAAMkB,EAASrV,OACRtC,EAAIyW,EAAKzW,IAChBwM,EAAQE,EAAUiL,EAAU3X,GAAKoS,EAElC,OAAOA,GAGR,QAASwF,GAAUC,EAAW5S,EAAKgD,EAAQkK,EAAS8E,GAOnD,IANA,GAAI3E,GACHwF,KACA9X,EAAI,EACJyW,EAAMoB,EAAUvV,OAChByV,EAAgB,MAAP9S,EAEFjF,EAAIyW,EAAKzW,KACTsS,EAAOuF,EAAW7X,MAClBiI,IAAUA,EAAQqK,EAAMH,EAAS8E,KACtCa,EAAazV,KAAMiQ,GACdyF,GACJ9S,EAAI5C,KAAMrC,IAMd,OAAO8X,GAGR,QAASE,GAAYC,EAAWvL,EAAUiK,EAASuB,EAAYC,EAAYC,GAO1E,MANKF,KAAeA,EAAYhE,KAC/BgE,EAAaF,EAAYE,IAErBC,IAAeA,EAAYjE,KAC/BiE,EAAaH,EAAYG,EAAYC,IAE/BxD,EAAc,SAAUvC,EAAMD,EAASD,EAAS8E,GACtD,GAAIoB,GAAMrY,EAAGsS,EACZgG,KACAC,KACAC,EAAcpG,EAAQ9P,OAGtBmW,EAAQpG,GAAQqF,EACfhL,GAAY,IACZyF,EAAQxM,UAAawM,GAAYA,MAKlCuG,GAAYT,IAAe5F,GAAS3F,EAEnC+L,EADAb,EAAUa,EAAOH,EAAQL,EAAW9F,EAAS8E,GAG9C0B,EAAahC,EAGZwB,IAAgB9F,EAAO4F,EAAYO,GAAeN,MAMjD9F,EACDsG,CAQF,IALK/B,GACJA,EAAS+B,EAAWC,EAAYxG,EAAS8E,GAIrCiB,EAMJ,IALAG,EAAOT,EAAUe,EAAYJ,GAC7BL,EAAYG,KAAUlG,EAAS8E,GAG/BjX,EAAIqY,EAAK/V,OACDtC,MACAsS,EAAO+F,EAAMrY,MACnB2Y,EAAYJ,EAASvY,MAAW0Y,EAAWH,EAASvY,IAAQsS,GAK/D,IAAKD,GACJ,GAAK8F,GAAcF,EAAY,CAC9B,GAAKE,EAAa,CAKjB,IAFAE,KACArY,EAAI2Y,EAAWrW,OACPtC,MACAsS,EAAOqG,EAAY3Y,KAGzBqY,EAAKhW,KAAQqW,EAAW1Y,GAAMsS,EAGhC6F,GAAY,KAAQQ,KAAmBN,EAAMpB,GAK9C,IADAjX,EAAI2Y,EAAWrW,OACPtC,MACAsS,EAAOqG,EAAY3Y,MACvBqY,EAAOF,EAAa/Q,GAASiL,EAAMC,GAASgG,EAAQtY,KAAS,IAE/DqS,EAAMgG,KAAYjG,EAASiG,GAAS/F,SAOvCqG,GAAaf,EACZe,IAAevG,EACduG,EAAWC,OAAQJ,EAAaG,EAAWrW,QAC3CqW,GAEGR,EACJA,EAAY,KAAM/F,EAASuG,EAAY1B,GAEvC5U,GAAK6Q,MAAOd,EAASuG,KAMzB,QAASE,GAAmBrC,GAyB3B,IAxBA,GAAIsC,GAAcnC,EAASN,EAC1BI,EAAMD,EAAOlU,OACbyW,EAAkBrE,EAAKsE,SAAUxC,EAAQ,GAAIhR,MAC7CyT,EAAmBF,GAAmBrE,EAAKsE,SAAU,KACrDhZ,EAAI+Y,EAAkB,EAAI,EAG1BG,EAAexC,EAAe,SAAUpE,GACvC,MAAOA,KAASwG,GACdG,GAAkB,GACrBE,EAAkBzC,EAAe,SAAUpE,GAC1C,MAAOlL,IAAS0R,EAAcxG,IAAU,GACtC2G,GAAkB,GACrBxB,GAAa,SAAUnF,EAAMH,EAAS8E,GACrC,GAAImC,IAASL,IAAqB9B,GAAO9E,IAAYkH,MAClDP,EAAe3G,GAAUxM,SAC1BuT,EAAc5G,EAAMH,EAAS8E,GAC7BkC,EAAiB7G,EAAMH,EAAS8E,GAIlC,OADA6B,GAAe,KACRM,IAGDpZ,EAAIyW,EAAKzW,IAChB,GAAO2W,EAAUjC,EAAKsE,SAAUxC,EAAQxW,GAAIwF,MAC3CiS,GAAaf,EAAec,EAAgBC,GAAYd,QAClD,CAIN,GAHAA,EAAUjC,EAAKzM,OAAQuO,EAAQxW,GAAIwF,MAAO0N,MAAO,KAAMsD,EAAQxW,GAAIiK,SAG9D0M,EAASzC,GAAY,CAIzB,IADAmC,IAAMrW,EACEqW,EAAII,IACN/B,EAAKsE,SAAUxC,EAAQH,GAAI7Q,MADhB6Q,KAKjB,MAAO2B,GACNhY,EAAI,GAAKwX,EAAgBC,GACzBzX,EAAI,GAAKoU,EAGToC,EACEzH,MAAO,EAAG/O,EAAI,GACdwD,QAAUnD,MAAgC,MAAzBmW,EAAQxW,EAAI,GAAIwF,KAAe,IAAM,MACtD1C,QAASyR,GAAO,MAClBoC,EACA3W,EAAIqW,GAAKwC,EAAmBrC,EAAOzH,MAAO/O,EAAGqW,IAC7CA,EAAII,GAAOoC,EAAqBrC,EAASA,EAAOzH,MAAOsH,IACvDA,EAAII,GAAOrC,EAAYoC,IAGzBiB,EAASpV,KAAMsU,GAIjB,MAAOa,GAAgBC,GAGxB,QAAS6B,GAA0BC,EAAiBC,GACnD,GAAIC,GAAQD,EAAYlX,OAAS,EAChCoX,EAAYH,EAAgBjX,OAAS,EACrCqX,EAAe,SAAUtH,EAAMF,EAAS8E,EAAK7E,EAASwH,GACrD,GAAItH,GAAM+D,EAAGM,EACZkD,EAAe,EACf7Z,EAAI,IACJ6X,EAAYxF,MACZyH,KACAC,EAAgBV,EAGhBZ,EAAQpG,GAAQqH,GAAahF,EAAKlM,KAAL,IAAoB,IAAKoR,GAGtDI,EAAkB1C,GAA4B,MAAjByC,EAAwB,EAAIE,KAAKC,UAAY,GAC1EzD,EAAMgC,EAAMnW,MAcb,KAZKsX,IAMJP,EAAmBlH,GAAW7K,GAAY6K,GAAWyH,GAM9C5Z,IAAMyW,GAAgC,OAAvBnE,EAAOmG,EAAOzY,IAAeA,IAAM,CACzD,GAAK0Z,GAAapH,EAAO,CAWxB,IAVA+D,EAAI,EAMElE,GAAWG,EAAKK,eAAiBrL,IACtCsL,EAAaN,GACb2E,GAAOpE,GAEE8D,EAAU4C,EAAiBlD,MACpC,GAAKM,EAASrE,EAAMH,GAAW7K,EAAU2P,GAAQ,CAChD7E,EAAQ/P,KAAMiQ,EACd,OAGGsH,IACJtC,EAAU0C,GAKPP,KAGGnH,GAAQqE,GAAWrE,IACzBuH,IAIIxH,GACJwF,EAAUxV,KAAMiQ,IAgBnB,GATAuH,GAAgB7Z,EASXyZ,GAASzZ,IAAM6Z,EAAe,CAElC,IADAxD,EAAI,EACMM,EAAU6C,EAAanD,MAChCM,EAASkB,EAAWiC,EAAY3H,EAAS8E,EAG1C,IAAK5E,EAAO,CAGX,GAAKwH,EAAe,EACnB,KAAQ7Z,KACC6X,EAAW7X,IAAO8Z,EAAY9Z,KACrC8Z,EAAY9Z,GAAMiP,GAAI/O,KAAMkS,GAM/B0H,GAAalC,EAAUkC,GAIxBzX,GAAK6Q,MAAOd,EAAS0H,GAGhBF,IAAcvH,GAAQyH,EAAWxX,OAAS,GAC5CuX,EAAeL,EAAYlX,OAAW,GAExCkK,EAAO2N,WAAY/H,GAUrB,MALKwH,KACJtC,EAAU0C,EACVX,EAAmBU,GAGblC,EAGT,OAAO4B,GACN7E,EAAc+E,GACdA,EAltEF,GAAI3Z,GACHoT,EACAsB,EACA0F,EACAC,EACAlG,EACAmG,EACA5V,EACA2U,EACAkB,EACAC,EAGA5H,EACAtL,EACAmT,EACA5H,EACAW,EACAkH,EACAzQ,EACA5C,EAGA6M,EAAU,SAAW,EAAI,GAAIyG,MAC7BC,EAAe1I,EAAO5K,SACtBgQ,EAAU,EACVlV,EAAO,EACPyY,EAAarG,IACbsG,EAAatG,IACbuG,EAAgBvG,IAChBjB,EAAyBiB,IACzBwG,EAAY,SAAUnS,EAAG2M,GAIxB,MAHK3M,KAAM2M,IACVgF,GAAe,GAET,GAIRS,KAAgB7Z,eAChBK,MACAwN,GAAMxN,GAAIwN,IACViM,GAAazZ,GAAIY,KACjBA,GAAOZ,GAAIY,KACX0M,GAAQtN,GAAIsN,MAIZ3H,GAAU,SAAU+T,EAAM7I,GAGzB,IAFA,GAAItS,GAAI,EACPyW,EAAM0E,EAAK7Y,OACJtC,EAAIyW,EAAKzW,IAChB,GAAKmb,EAAMnb,KAAQsS,EAClB,MAAOtS,EAGT,QAAQ,GAGTob,GAAW,6HAMXC,GAAa,sBAGbC,GAAa,0BAA4BD,GACxC,0CAGD3S,GAAa,MAAQ2S,GAAa,KAAOC,GAAa,OAASD,GAG9D,gBAAkBA,GAIlB,2DAA6DC,GAAa,OAC1ED,GAAa,OAEdE,GAAU,KAAOD,GAAa,wFAOA5S,GAAa,eAO3C8S,GAAc,GAAI/V,QAAQ4V,GAAa,IAAK,KAC5C9G,GAAQ,GAAI9O,QAAQ,IAAM4V,GAAa,8BACtCA,GAAa,KAAM,KAEpBI,GAAS,GAAIhW,QAAQ,IAAM4V,GAAa,KAAOA,GAAa,KAC5D1H,GAAe,GAAIlO,QAAQ,IAAM4V,GAAa,WAAaA,GAAa,IAAMA,GAC7E,KACD3H,GAAW,GAAIjO,QAAQ4V,GAAa,MAEpCK,GAAU,GAAIjW,QAAQ8V,IACtBI,GAAc,GAAIlW,QAAQ,IAAM6V,GAAa,KAE7CM,IACCC,GAAM,GAAIpW,QAAQ,MAAQ6V,GAAa,KACvCQ,MAAS,GAAIrW,QAAQ,QAAU6V,GAAa,KAC5CS,IAAO,GAAItW,QAAQ,KAAO6V,GAAa,SACvCU,KAAQ,GAAIvW,QAAQ,IAAMiD,IAC1BuT,OAAU,GAAIxW,QAAQ,IAAM8V,IAC5BW,MAAS,GAAIzW,QAAQ,yDACpB4V,GAAa,+BAAiCA,GAAa,cAC3DA,GAAa,aAAeA,GAAa,SAAU,KACpDc,KAAQ,GAAI1W,QAAQ,OAAS2V,GAAW,KAAM,KAI9CgB,aAAgB,GAAI3W,QAAQ,IAAM4V,GACjC,mDAAqDA,GACrD,mBAAqBA,GAAa,mBAAoB,MAGxDgB,GAAQ,SACRC,GAAU,sCACVC,GAAU,SAEVC,GAAU,yBAGV1J,GAAa,mCAEbc,GAAW,OAIX6I,GAAY,GAAIhX,QAAQ,uBAAyB4V,GAAa,uBAAwB,KACtFqB,GAAY,SAAUC,EAAQC,GAC7B,GAAIC,GAAO,KAAOF,EAAO5N,MAAO,GAAM,KAEtC,OAAO6N,KASNC,EAAO,EACNC,OAAOC,aAAcF,EAAO,OAC5BC,OAAOC,aAAcF,GAAQ,GAAK,MAAe,KAAPA,EAAe,SAK5D9I,GAAa,sDACbC,GAAa,SAAUgJ,EAAIC,GAC1B,MAAKA,GAGQ,OAAPD,EACG,IAIDA,EAAGjO,MAAO,GAAI,GAAM,KAC1BiO,EAAGE,WAAYF,EAAG1a,OAAS,GAAIuC,SAAU,IAAO,IAI3C,KAAOmY,GAOfG,GAAgB,WACfvK,KAGDsD,GAAqBQ,EACpB,SAAUpE,GACT,OAAyB,IAAlBA,EAAK0D,UAAqD,aAAhC1D,EAAKmB,SAASvK,gBAE9C2N,IAAK,aAAc1U,KAAM,UAI7B,KACCE,GAAK6Q,MACFzR,GAAMsN,GAAM7O,KAAM0a,EAAawC,YACjCxC,EAAawC,YAMd3b,GAAKmZ,EAAawC,WAAW9a,QAASqD,SACrC,MAAQsP,GACT5S,IAAS6Q,MAAOzR,GAAIa,OAGnB,SAAUwE,EAAQuW,GACjBnC,GAAWhI,MAAOpM,EAAQiI,GAAM7O,KAAMmd,KAKvC,SAAUvW,EAAQuW,GAKjB,IAJA,GAAIhH,GAAIvP,EAAOxE,OACdtC,EAAI,EAGK8G,EAAQuP,KAAQgH,EAAKrd,OAC/B8G,EAAOxE,OAAS+T,EAAI,IAiWvBjD,EAAU5G,EAAO4G,WAOjBiH,EAAQ7N,EAAO6N,MAAQ,SAAU/H,GAChC,GAAIgL,GAAYhL,GAAQA,EAAKiL,aAC5B9C,EAAUnI,IAAUA,EAAKK,eAAiBL,GAAOkL,eAKlD,QAAQnB,GAAM3Y,KAAM4Z,GAAa7C,GAAWA,EAAQhH,UAAY,SAQjEb,EAAcpG,EAAOoG,YAAc,SAAU7O,GAC5C,GAAI0Z,GAAYC,EACf9Q,EAAM7I,EAAOA,EAAK4O,eAAiB5O,EAAO6W,CAO3C,OAAKhO,IAAOtF,GAA6B,IAAjBsF,EAAIjH,UAAmBiH,EAAI4Q,iBAKnDlW,EAAWsF,EACX6N,EAAUnT,EAASkW,gBACnB3K,GAAkBwH,EAAO/S,GAQpBsT,GAAgBtT,IAClBoW,EAAYpW,EAASqW,cAAiBD,EAAUE,MAAQF,IAGrDA,EAAUG,iBACdH,EAAUG,iBAAkB,SAAUV,IAAe,GAG1CO,EAAUI,aACrBJ,EAAUI,YAAa,WAAYX,KASrC/J,EAAQU,MAAQgB,EAAQ,SAAUC,GAEjC,MADA0F,GAAQsD,YAAahJ,GAAKgJ,YAAazW,EAAS0N,cAAe,YACzB,KAAxBD,EAAG9J,mBACf8J,EAAG9J,iBAAkB,uBAAwB3I,SAShD8Q,EAAQ1K,WAAaoM,EAAQ,SAAUC,GAEtC,MADAA,GAAGjL,UAAY,KACPiL,EAAG3G,aAAc,eAO1BgF,EAAQD,qBAAuB2B,EAAQ,SAAUC,GAEhD,MADAA,GAAGgJ,YAAazW,EAAS0W,cAAe,MAChCjJ,EAAG5B,qBAAsB,KAAM7Q,SAIxC8Q,EAAQC,uBAAyBmJ,GAAQ9Y,KAAM4D,EAAS+L,wBAMxDD,EAAQ6K,QAAUnJ,EAAQ,SAAUC,GAEnC,MADA0F,GAAQsD,YAAahJ,GAAK9B,GAAKiB,GACvB5M,EAAS4W,oBAAsB5W,EAAS4W,kBAAmBhK,GAAU5R,SAIzE8Q,EAAQ6K,SACZvJ,EAAKzM,OAAL,GAAsB,SAAUgL,GAC/B,GAAIkL,GAASlL,EAAGnQ,QAAS2Z,GAAWC,GACpC,OAAO,UAAUpK,GAChB,MAAOA,GAAKlE,aAAc,QAAW+P,IAGvCzJ,EAAKlM,KAAL,GAAoB,SAAUyK,EAAId,GACjC,OAAuC,KAA3BA,EAAQa,gBAAkCH,EAAiB,CACtE,GAAIP,GAAOH,EAAQa,eAAgBC,EACnC,OAAOX,IAASA,UAIlBoC,EAAKzM,OAAL,GAAuB,SAAUgL,GAChC,GAAIkL,GAASlL,EAAGnQ,QAAS2Z,GAAWC,GACpC,OAAO,UAAUpK,GAChB,GAAIvO,OAAwC,KAA1BuO,EAAK8L,kBACtB9L,EAAK8L,iBAAkB,KACxB,OAAOra,IAAQA,EAAK1D,QAAU8d,IAMhCzJ,EAAKlM,KAAL,GAAoB,SAAUyK,EAAId,GACjC,OAAuC,KAA3BA,EAAQa,gBAAkCH,EAAiB,CACtE,GAAI9O,GAAM/D,EAAGyY,EACZnG,EAAOH,EAAQa,eAAgBC,EAEhC,IAAKX,EAAO,CAIX,IADAvO,EAAOuO,EAAK8L,iBAAkB,QACjBra,EAAK1D,QAAU4S,EAC3B,OAASX,EAMV,KAFAmG,EAAQtG,EAAQ+L,kBAAmBjL,GACnCjT,EAAI,EACMsS,EAAOmG,EAAOzY,MAEvB,IADA+D,EAAOuO,EAAK8L,iBAAkB,QACjBra,EAAK1D,QAAU4S,EAC3B,OAASX,GAKZ,YAMHoC,EAAKlM,KAAL,IAAqB4K,EAAQD,qBAC5B,SAAUnK,EAAKmJ,GACd,WAA6C,KAAjCA,EAAQgB,qBACZhB,EAAQgB,qBAAsBnK,GAG1BoK,EAAQE,IACZnB,EAAQlH,iBAAkBjC,OAD3B,IAKR,SAAUA,EAAKmJ,GACd,GAAIG,GACH+L,KACAre,EAAI,EAGJoS,EAAUD,EAAQgB,qBAAsBnK,EAGzC,IAAa,MAARA,EAAc,CAClB,KAAUsJ,EAAOF,EAASpS,MACF,IAAlBsS,EAAK3M,UACT0Y,EAAIhc,KAAMiQ,EAIZ,OAAO+L,GAER,MAAOjM,IAITsC,EAAKlM,KAAL,MAAuB4K,EAAQC,wBAA0B,SAAUvJ,EAAWqI,GAC7E,OAA+C,KAAnCA,EAAQkB,wBAA0CR,EAC7D,MAAOV,GAAQkB,uBAAwBvJ,IAUzC4Q,KAOAlH,MAEOJ,EAAQE,IAAMkJ,GAAQ9Y,KAAM4D,EAAS2D,qBAI3C6J,EAAQ,SAAUC,GAEjB,GAAI7D,EAOJuJ,GAAQsD,YAAahJ,GAAKuJ,UAAY,UAAYpK,EAAU,qBAC1CA,EAAU,kEAOvBa,EAAG9J,iBAAkB,wBAAyB3I,QAClDkR,EAAUnR,KAAM,SAAWgZ,GAAa,gBAKnCtG,EAAG9J,iBAAkB,cAAe3I,QACzCkR,EAAUnR,KAAM,MAAQgZ,GAAa,aAAeD,GAAW,KAI1DrG,EAAG9J,iBAAkB,QAAUiJ,EAAU,MAAO5R,QACrDkR,EAAUnR,KAAM,MAQjB6O,EAAQ5J,EAAS0N,cAAe,SAChC9D,EAAM+C,aAAc,OAAQ,IAC5Bc,EAAGgJ,YAAa7M,GACV6D,EAAG9J,iBAAkB,aAAc3I,QACxCkR,EAAUnR,KAAM,MAAQgZ,GAAa,QAAUA,GAAa,KAC3DA,GAAa,gBAMTtG,EAAG9J,iBAAkB,YAAa3I,QACvCkR,EAAUnR,KAAM,YAMX0S,EAAG9J,iBAAkB,KAAOiJ,EAAU,MAAO5R,QAClDkR,EAAUnR,KAAM,YAKjB0S,EAAG9J,iBAAkB,QACrBuI,EAAUnR,KAAM,iBAGjByS,EAAQ,SAAUC,GACjBA,EAAGuJ,UAAY,mFAKf,IAAIpN,GAAQ5J,EAAS0N,cAAe,QACpC9D,GAAM+C,aAAc,OAAQ,UAC5Bc,EAAGgJ,YAAa7M,GAAQ+C,aAAc,OAAQ,KAIzCc,EAAG9J,iBAAkB,YAAa3I,QACtCkR,EAAUnR,KAAM,OAASgZ,GAAa,eAKW,IAA7CtG,EAAG9J,iBAAkB,YAAa3I,QACtCkR,EAAUnR,KAAM,WAAY,aAK7BoY,EAAQsD,YAAahJ,GAAKiB,UAAW,EACc,IAA9CjB,EAAG9J,iBAAkB,aAAc3I,QACvCkR,EAAUnR,KAAM,WAAY,aAK7B0S,EAAG9J,iBAAkB,QACrBuI,EAAUnR,KAAM,YAIX+Q,EAAQmL,gBAAkB/B,GAAQ9Y,KAAQuG,EAAUwQ,EAAQxQ,SAClEwQ,EAAQ+D,uBACR/D,EAAQgE,oBACRhE,EAAQiE,kBACRjE,EAAQkE,qBAER7J,EAAQ,SAAUC,GAIjB3B,EAAQwL,kBAAoB3U,EAAQ/J,KAAM6U,EAAI,KAI9C9K,EAAQ/J,KAAM6U,EAAI,aAClB2F,EAAcrY,KAAM,KAAMkZ,MAI5B/H,EAAYA,EAAUlR,QAAU,GAAImD,QAAQ+N,EAAUrH,KAAM,MAC5DuO,EAAgBA,EAAcpY,QAAU,GAAImD,QAAQiV,EAAcvO,KAAM,MAIxEsR,EAAajB,GAAQ9Y,KAAM+W,EAAQoE,yBAKnCxX,EAAWoW,GAAcjB,GAAQ9Y,KAAM+W,EAAQpT,UAC9C,SAAUwB,EAAG2M,GACZ,GAAIsJ,GAAuB,IAAfjW,EAAElD,SAAiBkD,EAAE2U,gBAAkB3U,EAClDkW,EAAMvJ,GAAKA,EAAEtP,UACd,OAAO2C,KAAMkW,MAAWA,GAAwB,IAAjBA,EAAIpZ,YAClCmZ,EAAMzX,SACLyX,EAAMzX,SAAU0X,GAChBlW,EAAEgW,yBAA8D,GAAnChW,EAAEgW,wBAAyBE,MAG3D,SAAUlW,EAAG2M,GACZ,GAAKA,EACJ,KAAUA,EAAIA,EAAEtP,YACf,GAAKsP,IAAM3M,EACV,OAAO,CAIV,QAAO,GAOTmS,EAAYyC,EACZ,SAAU5U,EAAG2M,GAGZ,GAAK3M,IAAM2M,EAEV,MADAgF,IAAe,EACR,CAIR,IAAInV,IAAWwD,EAAEgW,yBAA2BrJ,EAAEqJ,uBAC9C,OAAKxZ,KASLA,GAAYwD,EAAE8J,eAAiB9J,KAAS2M,EAAE7C,eAAiB6C,GAC1D3M,EAAEgW,wBAAyBrJ,GAG3B,EAGc,EAAVnQ,IACD+N,EAAQ4L,cAAgBxJ,EAAEqJ,wBAAyBhW,KAAQxD,EAOzDwD,GAAKvB,GAAYuB,EAAE8J,eAAiBiI,GACxCvT,EAAUuT,EAAc/R,IAChB,EAOJ2M,GAAKlO,GAAYkO,EAAE7C,eAAiBiI,GACxCvT,EAAUuT,EAAcpF,GACjB,EAID+E,EACJnT,GAASmT,EAAW1R,GAAMzB,GAASmT,EAAW/E,GAChD,EAGe,EAAVnQ,GAAe,EAAI,IAE3B,SAAUwD,EAAG2M,GAGZ,GAAK3M,IAAM2M,EAEV,MADAgF,IAAe,EACR,CAGR,IAAI/E,GACHzV,EAAI,EACJif,EAAMpW,EAAE3C,WACR6Y,EAAMvJ,EAAEtP,WACRgZ,GAAOrW,GACPsW,GAAO3J,EAGR,KAAMyJ,IAAQF,EAMb,MAAOlW,IAAKvB,GAAY,EACvBkO,GAAKlO,EAAW,EAEhB2X,GAAO,EACPF,EAAM,EACNxE,EACEnT,GAASmT,EAAW1R,GAAMzB,GAASmT,EAAW/E,GAChD,CAGK,IAAKyJ,IAAQF,EACnB,MAAOxJ,GAAc1M,EAAG2M,EAKzB,KADAC,EAAM5M,EACI4M,EAAMA,EAAIvP,YACnBgZ,EAAG7Y,QAASoP,EAGb,KADAA,EAAMD,EACIC,EAAMA,EAAIvP,YACnBiZ,EAAG9Y,QAASoP,EAIb,MAAQyJ,EAAIlf,KAAQmf,EAAInf,IACvBA,GAGD,OAAOA,GAGNuV,EAAc2J,EAAIlf,GAAKmf,EAAInf,IAO3Bkf,EAAIlf,IAAO4a,GAAgB,EAC3BuE,EAAInf,IAAO4a,EAAe,EAE1B,GAGKtT,GA/cCA,GAkdTkF,EAAOvC,QAAU,SAAUmV,EAAMtS,GAChC,MAAON,GAAQ4S,EAAM,KAAM,KAAMtS,IAGlCN,EAAO+R,gBAAkB,SAAUjM,EAAM8M,GAGxC,GAFAxM,EAAaN,GAERc,EAAQmL,iBAAmB1L,IAC9BU,EAAwB6L,EAAO,QAC7B1E,IAAkBA,EAAchX,KAAM0b,OACtC5L,IAAkBA,EAAU9P,KAAM0b,IAErC,IACC,GAAIhG,GAAMnP,EAAQ/J,KAAMoS,EAAM8M,EAG9B,IAAKhG,GAAOhG,EAAQwL,mBAInBtM,EAAKhL,UAAuC,KAA3BgL,EAAKhL,SAAS3B,SAC/B,MAAOyT,GAEP,MAAQnE,GACT1B,EAAwB6L,GAAM,GAIhC,MAAO5S,GAAQ4S,EAAM9X,EAAU,MAAQgL,IAAShQ,OAAS,GAG1DkK,EAAOnF,SAAW,SAAU8K,EAASG,GAUpC,OAHOH,EAAQQ,eAAiBR,IAAa7K,GAC5CsL,EAAaT,GAEP9K,EAAU8K,EAASG,IAG3B9F,EAAO6S,KAAO,SAAU/M,EAAM/R,IAOtB+R,EAAKK,eAAiBL,IAAUhL,GACtCsL,EAAaN,EAGd,IAAIuC,GAAKH,EAAKY,WAAY/U,EAAK2I,eAG9BN,EAAMiM,GAAMoG,EAAO/a,KAAMwU,EAAKY,WAAY/U,EAAK2I,eAC9C2L,EAAIvC,EAAM/R,GAAOsS,OACjB/Q,EAEF,YAAeA,KAAR8G,EACNA,EACAwK,EAAQ1K,aAAemK,EACtBP,EAAKlE,aAAc7N,IACjBqI,EAAM0J,EAAK8L,iBAAkB7d,KAAYqI,EAAI0W,UAC9C1W,EAAIvI,MACJ,MAGJmM,EAAOmQ,OAAS,SAAU4C,GACzB,OAASA,EAAM,IAAKzc,QAASiR,GAAYC,KAG1CxH,EAAOgT,MAAQ,SAAUC,GACxB,KAAM,IAAI9Q,OAAO,0CAA4C8Q,IAO9DjT,EAAO2N,WAAa,SAAU/H,GAC7B,GAAIE,GACHoN,KACArJ,EAAI,EACJrW,EAAI,CAOL,IAJAwa,GAAgBpH,EAAQuM,iBACxBpF,GAAanH,EAAQwM,YAAcxN,EAAQrD,MAAO,GAClDqD,EAAQ5E,KAAMwN,GAETR,EAAe,CACnB,KAAUlI,EAAOF,EAASpS,MACpBsS,IAASF,EAASpS,KACtBqW,EAAIqJ,EAAWrd,KAAMrC,GAGvB,MAAQqW,KACPjE,EAAQwG,OAAQ8G,EAAYrJ,GAAK,GAQnC,MAFAkE,GAAY,KAELnI,GAORgI,EAAU5N,EAAO4N,QAAU,SAAU9H,GACpC,GAAIvO,GACHqV,EAAM,GACNpZ,EAAI,EACJ2F,EAAW2M,EAAK3M,QAEjB,IAAMA,GAQC,GAAkB,IAAbA,GAA+B,IAAbA,GAA+B,KAAbA,EAAkB,CAIjE,GAAiC,gBAArB2M,GAAK3H,YAChB,MAAO2H,GAAK3H,WAIZ,KAAM2H,EAAOA,EAAK1H,WAAY0H,EAAMA,EAAOA,EAAKsD,YAC/CwD,GAAOgB,EAAS9H,OAGZ,IAAkB,IAAb3M,GAA+B,IAAbA,EAC7B,MAAO2M,GAAKzH,cAnBZ,MAAU9G,EAAOuO,EAAMtS,MAGtBoZ,GAAOgB,EAASrW,EAqBlB,OAAOqV,IAGR1E,EAAOlI,EAAOqT,WAGblL,YAAa,GAEbmL,aAAclL,EAEd9Q,MAAO8X,GAEPtG,cAEA9M,QAEAwQ,UACC+G,KAAOlJ,IAAK,aAAcG,OAAO,GACjCgJ,KAAOnJ,IAAK,cACZoJ,KAAOpJ,IAAK,kBAAmBG,OAAO,GACtCkJ,KAAOrJ,IAAK,oBAGboB,WACC+D,KAAQ,SAAUlY,GAWjB,MAVAA,GAAO,GAAMA,EAAO,GAAIhB,QAAS2Z,GAAWC,IAG5C5Y,EAAO,IAAQA,EAAO,IAAOA,EAAO,IACnCA,EAAO,IAAO,IAAKhB,QAAS2Z,GAAWC,IAEpB,OAAf5Y,EAAO,KACXA,EAAO,GAAM,IAAMA,EAAO,GAAM,KAG1BA,EAAMiL,MAAO,EAAG,IAGxBmN,MAAS,SAAUpY,GAiClB,MArBAA,GAAO,GAAMA,EAAO,GAAIoF,cAEU,QAA7BpF,EAAO,GAAIiL,MAAO,EAAG,IAGnBjL,EAAO,IACZ0I,EAAOgT,MAAO1b,EAAO,IAKtBA,EAAO,KAASA,EAAO,GACtBA,EAAO,IAAQA,EAAO,IAAO,GAC7B,GAAqB,SAAfA,EAAO,IAAiC,QAAfA,EAAO,KACvCA,EAAO,KAAWA,EAAO,GAAMA,EAAO,IAAwB,QAAfA,EAAO,KAG3CA,EAAO,IAClB0I,EAAOgT,MAAO1b,EAAO,IAGfA,GAGRmY,OAAU,SAAUnY,GACnB,GAAIqc,GACHC,GAAYtc,EAAO,IAAOA,EAAO,EAElC,OAAK8X,IAAA,MAAqBlY,KAAMI,EAAO,IAC/B,MAIHA,EAAO,GACXA,EAAO,GAAMA,EAAO,IAAOA,EAAO,IAAO,GAG9Bsc,GAAY1E,GAAQhY,KAAM0c,KAGnCD,EAAShM,EAAUiM,GAAU,MAG7BD,EAASC,EAAShZ,QAAS,IAAKgZ,EAAS9d,OAAS6d,GAAWC,EAAS9d,UAGxEwB,EAAO,GAAMA,EAAO,GAAIiL,MAAO,EAAGoR,GAClCrc,EAAO,GAAMsc,EAASrR,MAAO,EAAGoR,IAI1Brc,EAAMiL,MAAO,EAAG,MAIzB9G,QAEC8T,IAAO,SAAUsE,GAChB,GAAI5M,GAAW4M,EAAiBvd,QAAS2Z,GAAWC,IAAYxT,aAChE,OAA4B,MAArBmX,EACN,WACC,OAAO,GAER,SAAU/N,GACT,MAAOA,GAAKmB,UAAYnB,EAAKmB,SAASvK,gBAAkBuK,IAI3DqI,MAAS,SAAUhS,GAClB,GAAI3D,GAAU0U,EAAY/Q,EAAY,IAEtC,OAAO3D,KACJA,EAAU,GAAIV,QAAQ,MAAQ4V,GAC/B,IAAMvR,EAAY,IAAMuR,GAAa,SAAaR,EACjD/Q,EAAW,SAAUwI,GACpB,MAAOnM,GAAQzC,KACY,gBAAnB4O,GAAKxI,WAA0BwI,EAAKxI,eACd,KAAtBwI,EAAKlE,cACXkE,EAAKlE,aAAc,UACpB,OAKN4N,KAAQ,SAAUzb,EAAM+f,EAAU/U,GACjC,MAAO,UAAU+G,GAChB,GAAIzK,GAAS2E,EAAO6S,KAAM/M,EAAM/R,EAEhC,OAAe,OAAVsH,EACgB,OAAbyY,GAEFA,IAINzY,GAAU,GAIU,MAAbyY,EAAmBzY,IAAW0D,EACvB,OAAb+U,EAAoBzY,IAAW0D,EAClB,OAAb+U,EAAoB/U,GAAqC,IAA5B1D,EAAOT,QAASmE,GAChC,OAAb+U,EAAoB/U,GAAS1D,EAAOT,QAASmE,IAAW,EAC3C,OAAb+U,EAAoB/U,GAAS1D,EAAOkH,OAAQxD,EAAMjJ,UAAaiJ,EAClD,OAAb+U,GAAsB,IAAMzY,EAAO/E,QAAS0Y,GAAa,KAAQ,KAAMpU,QAASmE,IAAW,EAC9E,OAAb+U,IAAoBzY,IAAW0D,GAAS1D,EAAOkH,MAAO,EAAGxD,EAAMjJ,OAAS,KAAQiJ,EAAQ,QAO3F2Q,MAAS,SAAU1W,EAAM+a,EAAMC,EAAWxJ,EAAOyJ,GAChD,GAAIC,GAAgC,QAAvBlb,EAAKuJ,MAAO,EAAG,GAC3B4R,EAA+B,SAArBnb,EAAKuJ,OAAQ,GACvB6R,EAAkB,YAATL,CAEV,OAAiB,KAAVvJ,GAAwB,IAATyJ,EAGrB,SAAUnO,GACT,QAASA,EAAKpM,YAGf,SAAUoM,EAAMuO,EAAU5J,GACzB,GAAIxC,GAAO0C,EAAaC,EAAYrT,EAAM+c,EAAWC,EACpDlK,EAAM6J,IAAWC,EAAU,cAAgB,kBAC3CnZ,EAAS8K,EAAKpM,WACd3F,EAAOqgB,GAAUtO,EAAKmB,SAASvK,cAC/B8X,GAAY/J,IAAQ2J,EACpBlL,GAAO,CAER,IAAKlO,EAAS,CAGb,GAAKkZ,EAAS,CACb,KAAQ7J,GAAM,CAEb,IADA9S,EAAOuO,EACGvO,EAAOA,EAAM8S,IACtB,GAAK+J,EACJ7c,EAAK0P,SAASvK,gBAAkB3I,EACd,IAAlBwD,EAAK4B,SAEL,OAAO,CAKTob,GAAQlK,EAAe,SAATrR,IAAoBub,GAAS,cAE5C,OAAO,EAMR,GAHAA,GAAUJ,EAAUnZ,EAAOoD,WAAapD,EAAOyZ,WAG1CN,GAAWK,GAkBf,IAbAjd,EAAOyD,EACP4P,EAAarT,EAAMmQ,KAAenQ,EAAMmQ,OAIxCiD,EAAcC,EAAYrT,EAAKwT,YAC5BH,EAAYrT,EAAKwT,cAEpB9C,EAAQ0C,EAAa3R,OACrBsb,EAAYrM,EAAO,KAAQ6C,GAAW7C,EAAO,GAC7CiB,EAAOoL,GAAarM,EAAO,GAC3B1Q,EAAO+c,GAAatZ,EAAO4V,WAAY0D,GAE7B/c,IAAS+c,GAAa/c,GAAQA,EAAM8S,KAG3CnB,EAAOoL,EAAY,IAAOC,EAAM9R,OAGlC,GAAuB,IAAlBlL,EAAK4B,YAAoB+P,GAAQ3R,IAASuO,EAAO,CACrD6E,EAAa3R,IAAW8R,EAASwJ,EAAWpL,EAC5C,YAyBF,IAlBKsL,IAGJjd,EAAOuO,EACP8E,EAAarT,EAAMmQ,KAAenQ,EAAMmQ,OAIxCiD,EAAcC,EAAYrT,EAAKwT,YAC5BH,EAAYrT,EAAKwT,cAEpB9C,EAAQ0C,EAAa3R,OACrBsb,EAAYrM,EAAO,KAAQ6C,GAAW7C,EAAO,GAC7CiB,EAAOoL,IAKM,IAATpL,EAGJ,MAAU3R,IAAS+c,GAAa/c,GAAQA,EAAM8S,KAC3CnB,EAAOoL,EAAY,IAAOC,EAAM9R,UAE3B2R,EACN7c,EAAK0P,SAASvK,gBAAkB3I,EACd,IAAlBwD,EAAK4B,cACH+P,IAGGsL,IACJ5J,EAAarT,EAAMmQ,KAChBnQ,EAAMmQ,OAITiD,EAAcC,EAAYrT,EAAKwT,YAC5BH,EAAYrT,EAAKwT,cAEpBJ,EAAa3R,IAAW8R,EAAS5B,IAG7B3R,IAASuO,MAUlB,OADAoD,GAAQ+K,KACQzJ,GAAWtB,EAAOsB,GAAU,GAAKtB,EAAOsB,GAAS,KAKrEiF,OAAU,SAAU1R,EAAQ6L,GAM3B,GAAI8K,GACHrM,EAAKH,EAAK6G,QAAShR,IAAYmK,EAAK6B,WAAYhM,EAAOrB,gBACtDsD,EAAOgT,MAAO,uBAAyBjV,EAKzC,OAAKsK,GAAIX,GACDW,EAAIuB,GAIPvB,EAAGvS,OAAS,GAChB4e,GAAS3W,EAAQA,EAAQ,GAAI6L,GACtB1B,EAAK6B,WAAWnV,eAAgBmJ,EAAOrB,eAC7C0L,EAAc,SAAUvC,EAAMpI,GAI7B,IAHA,GAAIkX,GACHC,EAAUvM,EAAIxC,EAAM+D,GACpBpW,EAAIohB,EAAQ9e,OACLtC,KACPmhB,EAAM/Z,GAASiL,EAAM+O,EAASphB,IAC9BqS,EAAM8O,KAAWlX,EAASkX,GAAQC,EAASphB,MAG7C,SAAUsS,GACT,MAAOuC,GAAIvC,EAAM,EAAG4O,KAIhBrM,IAIT0G,SAGC8F,IAAOzM,EAAc,SAAUlI,GAK9B,GAAIwE,MACHkB,KACAuE,EAAU2D,EAAS5N,EAAS5J,QAASyR,GAAO,MAE7C,OAAOoC,GAASzC,GACfU,EAAc,SAAUvC,EAAMpI,EAAS4W,EAAU5J,GAMhD,IALA,GAAI3E,GACHuF,EAAYlB,EAAStE,EAAM,KAAM4E,MACjCjX,EAAIqS,EAAK/P,OAGFtC,MACAsS,EAAOuF,EAAW7X,MACxBqS,EAAMrS,KAASiK,EAASjK,GAAMsS,MAIjC,SAAUA,EAAMuO,EAAU5J,GAMzB,MALA/F,GAAO,GAAMoB,EACbqE,EAASzF,EAAO,KAAM+F,EAAK7E,GAG3BlB,EAAO,GAAM,MACLkB,EAAQnD,SAInBqS,IAAO1M,EAAc,SAAUlI,GAC9B,MAAO,UAAU4F,GAChB,MAAO9F,GAAQE,EAAU4F,GAAOhQ,OAAS,KAI3C+E,SAAYuN,EAAc,SAAU7J,GAEnC,MADAA,GAAOA,EAAKjI,QAAS2Z,GAAWC,IACzB,SAAUpK,GAChB,OAASA,EAAK3H,aAAeyP,EAAS9H,IAASlL,QAAS2D,IAAU,KAWpEwW,KAAQ3M,EAAc,SAAU2M,GAO/B,MAJM5F,IAAYjY,KAAM6d,GAAQ,KAC/B/U,EAAOgT,MAAO,qBAAuB+B,GAEtCA,EAAOA,EAAKze,QAAS2Z,GAAWC,IAAYxT,cACrC,SAAUoJ,GAChB,GAAIkP,EACJ,IACC,GAAOA,EAAW3O,EACjBP,EAAKiP,KACLjP,EAAKlE,aAAc,aAAgBkE,EAAKlE,aAAc,QAGtD,OADAoT,EAAWA,EAAStY,iBACAqY,GAA2C,IAAnCC,EAASpa,QAASma,EAAO,YAE3CjP,EAAOA,EAAKpM,aAAkC,IAAlBoM,EAAK3M,SAC7C,QAAO,KAKTmB,OAAU,SAAUwL,GACnB,GAAImP,GAAOvP,EAAOwP,UAAYxP,EAAOwP,SAASD,IAC9C,OAAOA,IAAQA,EAAK1S,MAAO,KAAQuD,EAAKW,IAGzC5T,KAAQ,SAAUiT,GACjB,MAAOA,KAASmI,GAGjBkH,MAAS,SAAUrP,GAClB,MAAOA,KAAShL,EAASsa,iBACrBta,EAASua,UAAYva,EAASua,gBAC7BvP,EAAK9M,MAAQ8M,EAAKwP,OAASxP,EAAKyP,WAItCC,QAAWjM,GAAsB,GACjCC,SAAYD,GAAsB,GAElCkM,QAAW,SAAU3P,GAIpB,GAAImB,GAAWnB,EAAKmB,SAASvK,aAC7B,OAAsB,UAAbuK,KAA0BnB,EAAK2P,SACxB,WAAbxO,KAA2BnB,EAAK4P,UAGpCA,SAAY,SAAU5P,GASrB,MALKA,GAAKpM,YAEToM,EAAKpM,WAAWic,eAGQ,IAAlB7P,EAAK4P,UAIbE,MAAS,SAAU9P,GAMlB,IAAMA,EAAOA,EAAK1H,WAAY0H,EAAMA,EAAOA,EAAKsD,YAC/C,GAAKtD,EAAK3M,SAAW,EACpB,OAAO,CAGT,QAAO,GAGR6B,OAAU,SAAU8K,GACnB,OAAQoC,EAAK6G,QAAL,MAAyBjJ,IAIlC+P,OAAU,SAAU/P,GACnB,MAAOiK,IAAQ7Y,KAAM4O,EAAKmB,WAG3BvC,MAAS,SAAUoB,GAClB,MAAOgK,IAAQ5Y,KAAM4O,EAAKmB,WAG3B6O,OAAU,SAAUhQ,GACnB,GAAI/R,GAAO+R,EAAKmB,SAASvK,aACzB,OAAgB,UAAT3I,GAAkC,WAAd+R,EAAK9M,MAA8B,WAATjF,GAGtDwK,KAAQ,SAAUuH,GACjB,GAAI+M,EACJ,OAAuC,UAAhC/M,EAAKmB,SAASvK,eACN,SAAdoJ,EAAK9M,OAIuC,OAAxC6Z,EAAO/M,EAAKlE,aAAc,UACN,SAAvBiR,EAAKnW,gBAIR8N,MAASb,EAAwB,WAChC,OAAS,KAGVsK,KAAQtK,EAAwB,SAAUoM,EAAejgB,GACxD,OAASA,EAAS,KAGnBkgB,GAAMrM,EAAwB,SAAUoM,EAAejgB,EAAQ8T,GAC9D,OAASA,EAAW,EAAIA,EAAW9T,EAAS8T,KAG7CqM,KAAQtM,EAAwB,SAAUG,EAAchU,GAEvD,IADA,GAAItC,GAAI,EACAA,EAAIsC,EAAQtC,GAAK,EACxBsW,EAAajU,KAAMrC,EAEpB,OAAOsW,KAGRoM,IAAOvM,EAAwB,SAAUG,EAAchU,GAEtD,IADA,GAAItC,GAAI,EACAA,EAAIsC,EAAQtC,GAAK,EACxBsW,EAAajU,KAAMrC,EAEpB,OAAOsW,KAGRqM,GAAMxM,EAAwB,SAAUG,EAAchU,EAAQ8T,GAM7D,IALA,GAAIpW,GAAIoW,EAAW,EAClBA,EAAW9T,EACX8T,EAAW9T,EACVA,EACA8T,IACQpW,GAAK,GACdsW,EAAajU,KAAMrC,EAEpB,OAAOsW,KAGRsM,GAAMzM,EAAwB,SAAUG,EAAchU,EAAQ8T,GAE7D,IADA,GAAIpW,GAAIoW,EAAW,EAAIA,EAAW9T,EAAS8T,IACjCpW,EAAIsC,GACbgU,EAAajU,KAAMrC,EAEpB,OAAOsW,OAKV5B,EAAK6G,QAAL,IAAwB7G,EAAK6G,QAAL,EAGxB,KAAMvb,KAAO6iB,OAAO,EAAMC,UAAU,EAAMC,MAAM,EAAMC,UAAU,EAAMC,OAAO,GAC5EvO,EAAK6G,QAASvb,GAAM6V,EAAmB7V,EAExC,KAAMA,KAAOkjB,QAAQ,EAAMC,OAAO,GACjCzO,EAAK6G,QAASvb,GAAM8V,EAAoB9V,EAKzCuW,GAAWpV,UAAYuT,EAAK0O,QAAU1O,EAAK6G,QAC3C7G,EAAK6B,WAAa,GAAIA,GAEtBpC,EAAW3H,EAAO2H,SAAW,SAAUzH,EAAU2W,GAChD,GAAIjC,GAAStd,EAAO0S,EAAQhR,EAC3B8d,EAAO9Q,EAAQ+Q,EACfC,EAAS1I,EAAYpO,EAAW,IAEjC,IAAK8W,EACJ,MAAOH,GAAY,EAAIG,EAAOzU,MAAO,EAOtC,KAJAuU,EAAQ5W,EACR8F,KACA+Q,EAAa7O,EAAKuD,UAEVqL,GAAQ,CAGTlC,KAAatd,EAAQ2X,GAAO1I,KAAMuQ,MAClCxf,IAGJwf,EAAQA,EAAMvU,MAAOjL,EAAO,GAAIxB,SAAYghB,GAE7C9Q,EAAOnQ,KAAQmU,OAGhB4K,GAAU,GAGHtd,EAAQ6P,GAAaZ,KAAMuQ,MACjClC,EAAUtd,EAAMkE,QAChBwO,EAAOnU,MACNhC,MAAO+gB,EAGP5b,KAAM1B,EAAO,GAAIhB,QAASyR,GAAO,OAElC+O,EAAQA,EAAMvU,MAAOqS,EAAQ9e,QAI9B,KAAMkD,IAAQkP,GAAKzM,SACXnE,EAAQ8X,GAAWpW,GAAOuN,KAAMuQ,KAAgBC,EAAY/d,MAChE1B,EAAQyf,EAAY/d,GAAQ1B,MAC9Bsd,EAAUtd,EAAMkE,QAChBwO,EAAOnU,MACNhC,MAAO+gB,EACP5b,KAAMA,EACNyE,QAASnG,IAEVwf,EAAQA,EAAMvU,MAAOqS,EAAQ9e,QAI/B,KAAM8e,EACL,MAOF,MAAOiC,GACNC,EAAMhhB,OACNghB,EACC9W,EAAOgT,MAAO9S,GAGdoO,EAAYpO,EAAU8F,GAASzD,MAAO,IA4ZzCuL,EAAU9N,EAAO8N,QAAU,SAAU5N,EAAU5I,GAC9C,GAAI9D,GACHwZ,KACAD,KACAiK,EAASzI,EAAerO,EAAW,IAEpC,KAAM8W,EAAS,CAOd,IAJM1f,IACLA,EAAQqQ,EAAUzH,IAEnB1M,EAAI8D,EAAMxB,OACFtC,KACPwjB,EAAS3K,EAAmB/U,EAAO9D,IAC9BwjB,EAAQtP,GACZsF,EAAYnX,KAAMmhB,GAElBjK,EAAgBlX,KAAMmhB,EAKxBA,GAASzI,EACRrO,EACA4M,EAA0BC,EAAiBC,IAI5CgK,EAAO9W,SAAWA,EAEnB,MAAO8W,IAYR9e,EAAS8H,EAAO9H,OAAS,SAAUgI,EAAUyF,EAASC,EAASC,GAC9D,GAAIrS,GAAGwW,EAAQiN,EAAOje,EAAMgD,EAC3Bkb,EAA+B,kBAAbhX,IAA2BA,EAC7C5I,GAASuO,GAAQ8B,EAAYzH,EAAWgX,EAAShX,UAAYA,EAM9D,IAJA0F,EAAUA,MAIY,IAAjBtO,EAAMxB,OAAe,CAIzB,GADAkU,EAAS1S,EAAO,GAAMA,EAAO,GAAIiL,MAAO,GACnCyH,EAAOlU,OAAS,GAAsC,QAA/BmhB,EAAQjN,EAAQ,IAAMhR,MAC5B,IAArB2M,EAAQxM,UAAkBkN,GAAkB6B,EAAKsE,SAAUxC,EAAQ,GAAIhR,MAAS,CAIhF,KAFA2M,GAAYuC,EAAKlM,KAAL,GAAmBib,EAAMxZ,QAAS,GAC5CnH,QAAS2Z,GAAWC,IAAavK,QAAmB,IAErD,MAAOC,EAGIsR,KACXvR,EAAUA,EAAQjM,YAGnBwG,EAAWA,EAASqC,MAAOyH,EAAOxO,QAAQ3H,MAAMiC,QAKjD,IADAtC,EAAI4b,GAAA,aAA4BlY,KAAMgJ,GAAa,EAAI8J,EAAOlU,OACtDtC,MACPyjB,EAAQjN,EAAQxW,IAGX0U,EAAKsE,SAAYxT,EAAOie,EAAMje,QAGnC,IAAOgD,EAAOkM,EAAKlM,KAAMhD,MAGjB6M,EAAO7J,EACbib,EAAMxZ,QAAS,GAAInH,QAAS2Z,GAAWC,IACvC9I,GAASlQ,KAAM8S,EAAQ,GAAIhR,OAAUqO,EAAa1B,EAAQjM,aACzDiM,IACI,CAKL,GAFAqE,EAAOoC,OAAQ5Y,EAAG,KAClB0M,EAAW2F,EAAK/P,QAAU8R,EAAYoC,IAGrC,MADAnU,IAAK6Q,MAAOd,EAASC,GACdD,CAGR,QAeJ,OAPEsR,GAAYpJ,EAAS5N,EAAU5I,IAChCuO,EACAF,GACCU,EACDT,GACCD,GAAWyB,GAASlQ,KAAMgJ,IAAcmH,EAAa1B,EAAQjM,aAAgBiM,GAExEC,GAMRgB,EAAQwM,WAAa1L,EAAQvK,MAAO,IAAK6D,KAAMwN,GAAY7O,KAAM,MAAS+H,EAI1Ed,EAAQuM,mBAAqBnF,EAG7B5H,IAIAQ,EAAQ4L,aAAelK,EAAQ,SAAUC,GAGxC,MAA4E,GAArEA,EAAG8J,wBAAyBvX,EAAS0N,cAAe,eAMtDF,EAAQ,SAAUC,GAEvB,MADAA,GAAGuJ,UAAY,mBACiC,MAAzCvJ,EAAGnK,WAAWwD,aAAc,WAEnC+G,EAAW,yBAA0B,SAAU7C,EAAM/R,EAAM8Z,GAC1D,IAAMA,EACL,MAAO/H,GAAKlE,aAAc7N,EAA6B,SAAvBA,EAAK2I,cAA2B,EAAI,KAOjEkK,EAAQ1K,YAAeoM,EAAQ,SAAUC,GAG9C,MAFAA,GAAGuJ,UAAY,WACfvJ,EAAGnK,WAAWqJ,aAAc,QAAS,IACY,KAA1Cc,EAAGnK,WAAWwD,aAAc,YAEnC+G,EAAW,QAAS,SAAU7C,EAAMqR,EAAOtJ,GAC1C,IAAMA,GAAyC,UAAhC/H,EAAKmB,SAASvK,cAC5B,MAAOoJ,GAAKsR,eAOT9O,EAAQ,SAAUC,GACvB,MAAwC,OAAjCA,EAAG3G,aAAc,eAExB+G,EAAWiG,GAAU,SAAU9I,EAAM/R,EAAM8Z,GAC1C,GAAIzR,EACJ,KAAMyR,EACL,OAAwB,IAAjB/H,EAAM/R,GAAkBA,EAAK2I,eACjCN,EAAM0J,EAAK8L,iBAAkB7d,KAAYqI,EAAI0W,UAC9C1W,EAAIvI,MACJ,MAML,IAAIwjB,IAAU3R,EAAO1F,MAErBA,GAAOsX,WAAa,WAKnB,MAJK5R,GAAO1F,SAAWA,IACtB0F,EAAO1F,OAASqX,IAGVrX,OAIP1K,MAAAmQ,EAAQ,WACP,MAAOzF,IADRtM,KAAAX,EAAAM,EAAAN,EAAAC,QAAAD,QAAA0S,IAaIC,STqmDC,SAAS1S,EAAQD,EAASM,GAEhC,YAyDA,SAASkkB,GAAwBrd,GAAO,GAAIA,GAAOA,EAAI1F,WAAc,MAAO0F,EAAc,IAAIsd,KAAa,IAAW,MAAPtd,EAAe,IAAK,GAAIM,KAAON,GAAWhG,OAAOS,UAAUC,eAAelB,KAAKwG,EAAKM,KAAMgd,EAAOhd,GAAON,EAAIM,GAAgC,OAAtBgd,GAAO/c,QAAUP,EAAYsd,EAElQ,QAAShT,GAAuBtK,GAAO,MAAOA,IAAOA,EAAI1F,WAAa0F,GAAQO,QAASP,GAxDvFhG,OAAOC,eAAepB,EAAS,cAC7Bc,OAAO,IAETd,EAAQ0kB,OAAS1kB,EAAQmP,SAAWnP,EAAQ4E,YAAc5E,EAAQuE,MAAQvE,EAAQ2kB,iBAAmB3kB,EAAQ4kB,kBAAoB5kB,EAAQmF,WAAS5C,EAElJ,IAAIsiB,GAAUvkB,EAAoB,EAElCa,QAAOC,eAAepB,EAAS,UAC7BsB,YAAY,EACZC,IAAK,WACH,MAAOkQ,GAAuBoT,GUjiIzBnd,WVoiITvG,OAAOC,eAAepB,EAAS,qBAC7BsB,YAAY,EACZC,IAAK,WACH,MAAOsjB,GUviIiBD,qBV0iI5BzjB,OAAOC,eAAepB,EAAS,oBAC7BsB,YAAY,EACZC,IAAK,WACH,MAAOsjB,GU7iIoCF,mBVijI/C,IAAI/W,GAAStN,EAAoB,EAEjCa,QAAOC,eAAepB,EAAS,SAC7BsB,YAAY,EACZC,IAAK,WACH,MAAOkQ,GAAuB7D,GUrjIzBlG,WVwjITvG,OAAOC,eAAepB,EAAS,eAC7BsB,YAAY,EACZC,IAAK,WACH,MAAOqM,GU3jIgBhJ,cV+jI3B,IAAIoN,GAAY1R,EAAoB,EAEpCa,QAAOC,eAAepB,EAAS,YAC7BsB,YAAY,EACZC,IAAK,WACH,MAAOkQ,GAAuBO,GUnkIzBtK,UVukIT,IAAIod,GAAWxkB,EAAoB,GAE/B4R,EAAUsS,EAAwBM,EAMtC9kB,GU9kIY0kB,OV8kIKxS","file":"optimal-select.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OptimalSelect\"] = factory();\n\telse\n\t\troot[\"OptimalSelect\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OptimalSelect\"] = factory();\n\telse\n\t\troot[\"OptimalSelect\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n/**\n * # Utilities\n *\n * Convenience helpers.\n */\n\n/**\n * Create an array with the DOM nodes of the list\n *\n * @param  {NodeList}             nodes - [description]\n * @return {Array.<HTMLElement>}        - [description]\n */\nvar convertNodeList = exports.convertNodeList = function convertNodeList(nodes) {\n  var length = nodes.length;\n\n  var arr = new Array(length);\n  for (var i = 0; i < length; i++) {\n    arr[i] = nodes[i];\n  }\n  return arr;\n};\n\n/**\n * Escape special characters and line breaks as a simplified version of 'CSS.escape()'\n *\n * Description of valid characters: https://mathiasbynens.be/notes/css-escapes\n *\n * @param  {String?} value - [description]\n * @return {String}        - [description]\n */\nvar escapeValue = exports.escapeValue = function escapeValue(value) {\n  return value && value.replace(/['\"`\\\\/:?&!#$%^()[\\]{|}*+;,.<=>@~]/g, '\\\\$&').replace(/\\n/g, '\\xA0');\n};\n\n/**\n * Partition array into two groups determined by predicate\n */\nvar partition = exports.partition = function partition(array, predicate) {\n  return array.reduce(function (_ref, item) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        inner = _ref2[0],\n        outer = _ref2[1];\n\n    return predicate(item) ? [inner.concat(item), outer] : [inner, outer.concat(item)];\n  }, [[], []]);\n};\n\n/**\n * Determine if string is valid CSS identifier\n * \n * In CSS, identifiers (including element names, classes, and IDs in selectors) can contain\n * only the characters [a-zA-Z0-9] and ISO 10646 characters U+00A0 and higher, plus the hyphen (-)\n * and the underscore (_); they cannot start with a digit, two hyphens, or a hyphen followed by\n * a digit.\n * \n * Identifiers can also contain escaped characters and any ISO 10646 character as a numeric\n * code (see next item). For instance, the identifier \"B&W?\" may be written as \"B\\&W\\?\" or \"B\\26 W\\3F\".\n * @param {String} value \n * @return {Boolean}\n */\nvar isValidCSSIdentifier = exports.isValidCSSIdentifier = function isValidCSSIdentifier(value) {\n  return !!value && !/(^\\d)|(^--)|(^-\\d)/.test(value) && !/([^\\\\]|^)['\"`/:?&!#$%^()[\\]{|}*+;,.<=>@~]/.test(value);\n};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkIgnore = exports.combinations = exports.initOptions = exports.defaultIgnore = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**\n                                                                                                                                                                                                                                                                   * # Match\n                                                                                                                                                                                                                                                                   *\n                                                                                                                                                                                                                                                                   * Retrieve selector for a node.\n                                                                                                                                                                                                                                                                   */\n\nexports.default = match;\n\nvar _pattern = __webpack_require__(2);\n\nvar _selector = __webpack_require__(3);\n\nvar _utilities = __webpack_require__(0);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * @typedef {import('./select').Options} Options\n * @typedef {import('./pattern').Pattern} Pattern\n * @typedef {import('./pattern').ToStringApi} Pattern\n */\n\nvar defaultIgnore = exports.defaultIgnore = {\n  attribute: function attribute(attributeName) {\n    return ['style', 'data-reactid', 'data-react-checksum'].indexOf(attributeName) > -1;\n  },\n\n  contains: function contains() {\n    return true;\n  }\n};\n\nvar initOptions = exports.initOptions = function initOptions() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return _extends({}, options, {\n    root: options.root || document,\n    skip: options.skip || null,\n    priority: options.priority || ['id', 'class', 'href', 'src'],\n    ignore: options.ignore || {}\n  });\n};\n\n/**\n * Get the path of the element\n *\n * @param  {HTMLElement} node      - [description]\n * @param  {Options}     [options] - [description]\n * @return {Array.<Pattern>}       - [description]\n */\nfunction match(node) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var nested = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  options = initOptions(options);\n  var _options = options,\n      root = _options.root,\n      skip = _options.skip,\n      ignore = _options.ignore,\n      format = _options.format;\n\n\n  var path = [];\n  var element = node;\n  var length = path.length;\n  var select = (0, _selector.getSelect)(options);\n  var toString = (0, _pattern.getToString)(options);\n\n  var skipCompare = skip && (Array.isArray(skip) ? skip : [skip]).map(function (entry) {\n    if (typeof entry !== 'function') {\n      return function (element) {\n        return element === entry;\n      };\n    }\n    return entry;\n  });\n\n  var skipChecks = function skipChecks(element) {\n    return skip && skipCompare.some(function (compare) {\n      return compare(element);\n    });\n  };\n\n  Object.keys(ignore).forEach(function (type) {\n    var predicate = ignore[type];\n    if (typeof predicate === 'function') return;\n    if (typeof predicate === 'number') {\n      predicate = predicate.toString();\n    }\n    if (typeof predicate === 'string') {\n      predicate = new RegExp((0, _utilities.escapeValue)(predicate).replace(/\\\\/g, '\\\\\\\\'));\n    }\n    if (typeof predicate === 'boolean') {\n      predicate = predicate ? /(?:)/ : /.^/;\n    }\n    // check class-/attributename for regex\n    ignore[type] = function (name, value) {\n      return predicate.test(value);\n    };\n  });\n\n  while (element !== root && element.nodeType !== 11) {\n    if (skipChecks(element) !== true) {\n      // ~ global\n      if (checkAttributes(element, path, options, select, toString, root)) break;\n      if (checkTag(element, path, options, select, toString, root)) break;\n\n      // ~ local\n      checkAttributes(element, path, options, select, toString);\n      if (path.length === length) {\n        checkTag(element, path, options, select, toString);\n      }\n\n      if (path.length === length && [1, 'xpath'].includes(format) && !nested && element === node) {\n        checkRecursiveDescendants(element, path, options, select, toString);\n      }\n\n      if (path.length === length && [1, 'xpath', 'jquery'].includes(format)) {\n        checkText(element, path, options, select, toString, format === 'jquery');\n      }\n\n      if (path.length === length) {\n        checkNthChild(element, path, options);\n      }\n    }\n\n    element = element.parentNode;\n    length = path.length;\n  }\n\n  if (element === root) {\n    var pattern = findPattern(element, options, select, toString);\n    path.unshift(pattern);\n  }\n\n  return path;\n}\n\n/**\n * Extend path with attribute identifier\n *\n * @param  {HTMLElement}     element  - [description]\n * @param  {Array.<Pattern>} path     - [description]\n * @param  {Options}         options  - [description]\n * @param  {function}        select   - [description]\n * @param  {ToStringApi}     toString - [description]\n * @param  {HTMLElement}     parent   - [description]\n * @return {boolean}                  - [description]\n */\nvar checkAttributes = function checkAttributes(element, path, _ref, select, toString) {\n  var priority = _ref.priority,\n      ignore = _ref.ignore;\n  var parent = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : element.parentNode;\n\n  var pattern = findAttributesPattern(priority, element, ignore, select, toString, parent);\n  if (pattern) {\n    path.unshift(pattern);\n    return true;\n  }\n  return false;\n};\n\n/**\n * Calculates array of combinations of items in input array.\n * @param  {Array.<any>} values   - array of values\n * @param  {Object} options       - options: min - minimum subset size; max - maximum subset size\n * @return {Array.<Array.<any>>?}   array of subsets\n */\nvar combinations = exports.combinations = function combinations(values, options) {\n  var _ref2 = options || {},\n      min = _ref2.min,\n      max = _ref2.max;\n\n  var result = [[]];\n\n  values.forEach(function (v) {\n    result.forEach(function (r) {\n      if (!max || r.length < max) {\n        result.push(r.concat(v));\n      }\n    });\n  });\n\n  result.shift();\n  return min ? result.filter(function (r) {\n    return r.length >= min;\n  }) : result;\n};\n\n// limit subset size to increase performance\nvar maxSubsetSize = [{ items: 13, max: 1 }, { items: 10, max: 2 }, { items: 8, max: 3 }, { items: 5, max: 4 }];\n\n/**\n * Get class selector\n *\n * @param  {Array.<string>} classes - [description]\n * @param  {function}       select  - [description]\n * @param  {ToStringApi}    toString - [description]\n * @param  {HTMLElement}    parent  - [description]\n * @param  {Pattern}        base    - [description]\n * @return {Array.<string>?}        - [description]\n */\nvar getClassSelector = function getClassSelector() {\n  var classes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var select = arguments[1];\n  var toString = arguments[2];\n  var parent = arguments[3];\n  var base = arguments[4];\n\n  var _ref3 = maxSubsetSize.find(function (_ref4) {\n    var items = _ref4.items;\n    return classes.length > items;\n  }) || { max: classes.length },\n      max = _ref3.max;\n\n  var result = combinations(classes, { max: max });\n\n  for (var i = 0; i < result.length; i++) {\n    var pattern = toString.pattern(_extends({}, base, { classes: result[i] }));\n    var matches = select(pattern, parent);\n    if (matches.length === 1) {\n      return result[i];\n    }\n  }\n\n  return null;\n};\n\n/**\n * Lookup attribute identifier\n *\n * @param  {Array.<string>} priority  - [description]\n * @param  {HTMLElement}    element   - [description]\n * @param  {Object}         ignore    - [description]\n * @param  {function}       select    - [description]\n * @param  {ToStringApi}    toString  - [description]\n * @param  {ParentNode}     parent    - [description]\n * @return {Pattern?}                 - [description]\n */\nvar findAttributesPattern = function findAttributesPattern(priority, element, ignore, select, toString) {\n  var parent = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : element.parentNode;\n\n  var attributes = element.attributes;\n  var attributeNames = Object.keys(attributes).map(function (val) {\n    return attributes[val].name;\n  }).filter(function (a) {\n    return priority.indexOf(a) < 0;\n  });\n\n  var sortedKeys = [].concat(_toConsumableArray(priority), _toConsumableArray(attributeNames));\n  var pattern = (0, _pattern.createPattern)();\n  pattern.tag = element.tagName.toLowerCase();\n\n  var isOptimal = function isOptimal(pattern) {\n    return select(toString.pattern(pattern), parent).length === 1;\n  };\n\n  for (var i = 0, l = sortedKeys.length; i < l; i++) {\n    var key = sortedKeys[i];\n    var attribute = attributes[key];\n    var attributeName = (0, _utilities.escapeValue)(attribute && attribute.name);\n    var attributeValue = (0, _utilities.escapeValue)(attribute && attribute.value);\n    var useNamedIgnore = attributeName !== 'class';\n\n    var currentIgnore = useNamedIgnore && ignore[attributeName] || ignore.attribute;\n    var currentDefaultIgnore = useNamedIgnore && defaultIgnore[attributeName] || defaultIgnore.attribute;\n    if (checkIgnore(currentIgnore, attributeName, attributeValue, currentDefaultIgnore)) {\n      continue;\n    }\n\n    switch (attributeName) {\n      case 'class':\n        {\n          var _ret = function () {\n            var classNames = attributeValue.trim().split(/\\s+/g);\n            if (!classNames[0]) {\n              // empty string\n              return 'break';\n            }\n            var classIgnore = ignore.class || defaultIgnore.class;\n            if (classIgnore) {\n              classNames = classNames.filter(function (className) {\n                return !classIgnore(className);\n              });\n            }\n            if (classNames.length > 0) {\n              var classes = getClassSelector(classNames, select, toString, parent, pattern);\n              if (classes) {\n                pattern.classes = classes;\n                if (isOptimal(pattern)) {\n                  return {\n                    v: pattern\n                  };\n                }\n              }\n            }\n          }();\n\n          switch (_ret) {\n            case 'break':\n              break;\n\n            default:\n              if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n          }\n        }\n        break;\n\n      default:\n        pattern.attributes.push({ name: attributeName, value: attributeValue });\n        if (isOptimal(pattern)) {\n          return pattern;\n        }\n    }\n  }\n\n  return null;\n};\n\n/**\n * Extend path with tag identifier\n *\n * @param  {HTMLElement}     element - [description]\n * @param  {Options}         options  - [description]\n * @param  {Array.<Pattern>} path    - [description]\n * @param  {function}        select  - [description]\n * @param  {ToStringApi}     toString - [description]\n * @param  {HTMLElement}     parent  - [description]\n * @return {boolean}                 - [description]\n */\nvar checkTag = function checkTag(element, path, _ref5, select, toString) {\n  var ignore = _ref5.ignore;\n  var parent = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : element.parentNode;\n\n  var pattern = findTagPattern(element, ignore);\n  if (pattern) {\n    var matches = [];\n    matches = select(toString.pattern(pattern), parent);\n    if (matches.length === 1) {\n      path.unshift(pattern);\n      if (pattern.tag === 'iframe') {\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Lookup tag identifier\n *\n * @param  {HTMLElement} element - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Pattern?}            - [description]\n */\nvar findTagPattern = function findTagPattern(element, ignore) {\n  var tagName = element.tagName.toLowerCase();\n  if (checkIgnore(ignore.tag, null, tagName)) {\n    return null;\n  }\n  var pattern = (0, _pattern.createPattern)();\n  pattern.tag = tagName;\n  return pattern;\n};\n\n/**\n * Extend path with specific child identifier\n *\n * @param  {HTMLElement}     element - [description]\n * @param  {Options}         options - [description]\n * @param  {Array.<Pattern>} path    - [description]\n * @return {boolean}                 - [description]\n */\nvar checkNthChild = function checkNthChild(element, path, _ref6) {\n  var ignore = _ref6.ignore;\n\n  var parent = element.parentNode;\n  var children = parent.children;\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    if (child === element) {\n      var childPattern = findTagPattern(child, ignore);\n      if (!childPattern) {\n        return console.warn('\\n          Element couldn\\'t be matched through strict ignore pattern!\\n        ', child, ignore, childPattern);\n      }\n      childPattern.relates = 'child';\n      childPattern.pseudo = ['nth-child(' + (i + 1) + ')'];\n      path.unshift(childPattern);\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Extend path with contains\n *\n * @param  {HTMLElement}     element  - [description]\n * @param  {Array.<Pattern>} path     - [description]\n * @param  {Options}         options  - [description]\n * @param  {function}        select   - [description]\n * @param  {ToStringApi}     toString - [description]\n * @param  {boolean}         nested   - [description]\n * @return {boolean}                  - [description]\n */\nvar checkText = function checkText(element, path, _ref7, select, toString, nested) {\n  var ignore = _ref7.ignore;\n\n  var pattern = findTagPattern(element, ignore);\n  if (!pattern) {\n    return false;\n  }\n  var textContent = nested ? element.textContent : element.firstChild && element.firstChild.nodeValue || '';\n  if (!textContent) {\n    return false;\n  }\n\n  pattern.relates = 'child';\n  var parent = element.parentNode;\n  var texts = textContent.replace(/\\n+/g, '\\n').split('\\n').map(function (text) {\n    return text.trim();\n  }).filter(function (text) {\n    return text.length > 0;\n  });\n\n  var contains = [];\n\n  while (texts.length > 0) {\n    var text = texts.shift();\n    if (checkIgnore(ignore.contains, null, text, defaultIgnore.contains)) {\n      break;\n    }\n    contains.push('contains(\"' + text + '\")');\n\n    var matches = select(toString.pattern(_extends({}, pattern, { pseudo: contains })), parent);\n    if (matches.length === 1) {\n      pattern.pseudo = contains;\n      path.unshift(pattern);\n      return true;\n    }\n    if (matches.length === 0) {\n      return false;\n    }\n  }\n  return false;\n};\n\n/**\n * Extend path with descendant tag\n *\n * @param  {HTMLElement}     element  - [description]\n * @param  {Array.<Pattern>} path     - [description]\n * @param  {Options}         options  - [description]\n * @param  {function}        select   - [description]\n * @param  {ToStringApi}     toString - [description]\n * @return {boolean}                  - [description]\n */\nvar checkRecursiveDescendants = function checkRecursiveDescendants(element, path, options, select, toString) {\n  var pattern = findTagPattern(element, options.ignore);\n  if (!pattern) {\n    return false;\n  }\n\n  var descendants = Array.from(element.querySelectorAll('*'));\n  while (descendants.length > 0) {\n    var descendantPath = match(descendants.shift(), _extends({}, options, { root: element }), true);\n    // avoid descendant selectors with nth-child\n    if (!descendantPath.some(function (pattern) {\n      return pattern.pseudo.some(function (p) {\n        return p.startsWith('nth-child');\n      });\n    })) {\n      var parent = element.parentElement;\n      var matches = select(toString.pattern(_extends({}, pattern, { descendants: [descendantPath] })), parent);\n      if (matches.length === 1) {\n        pattern.descendants = [descendantPath];\n        path.unshift(pattern);\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n/**\n * Lookup identifier\n *\n * @param  {HTMLElement}    element  - [description]\n * @param  {Options}        options   - [description]\n * @param  {function}       select   - [description]\n * @param  {ToStringApi}    toString - [description]\n * @return {Pattern}                 - [description]\n */\nvar findPattern = function findPattern(element, _ref8, select, toString) {\n  var priority = _ref8.priority,\n      ignore = _ref8.ignore;\n\n  var pattern = findAttributesPattern(priority, element, ignore, select, toString);\n  if (!pattern) {\n    pattern = findTagPattern(element, ignore);\n  }\n  return pattern;\n};\n\n/**\n * Validate with custom and default functions\n *\n * @param  {Function} predicate        - [description]\n * @param  {string?}  name             - [description]\n * @param  {string}   value            - [description]\n * @param  {Function} defaultPredicate - [description]\n * @return {boolean}                   - [description]\n */\nvar checkIgnore = exports.checkIgnore = function checkIgnore(predicate, name, value, defaultPredicate) {\n  if (!value) {\n    return true;\n  }\n  var check = predicate || defaultPredicate;\n  if (!check) {\n    return false;\n  }\n  return check(name, value, defaultPredicate);\n};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getToString = exports.descendantsToXPath = exports.pathToXPath = exports.patternToXPath = exports.pseudoToXPath = exports.classesToXPath = exports.attributesToXPath = exports.pathToSelector = exports.patternToSelector = exports.pseudoToSelector = exports.classesToSelector = exports.attributesToSelector = exports.createPattern = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _utilities = __webpack_require__(0);\n\n/**\n * @typedef  {Object} Pattern\n * @property {('descendant' | 'child')}                  [relates]\n * @property {string}                                    [tag]\n * @property {Array.<{ name: string, value: string? }>}  attributes\n * @property {Array.<string>}                            classes\n * @property {Array.<string>}                            pseudo\n * @property {Array.<Array.<Pattern>>}                   descendants\n */\n\n/**\n * Creates a new pattern structure\n * \n * @param {Partial<Pattern>} pattern\n * @returns {Pattern}\n */\nvar createPattern = exports.createPattern = function createPattern() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return _extends({ attributes: [], classes: [], pseudo: [], descendants: [] }, base);\n};\n\n/**\n * Convert attributes to CSS selector\n * \n * @param {Array.<{ name: string, value: string? }>} attributes \n * @returns {string}\n */\nvar attributesToSelector = exports.attributesToSelector = function attributesToSelector(attributes) {\n  return attributes.map(function (_ref) {\n    var name = _ref.name,\n        value = _ref.value;\n\n    if (value === null) {\n      return '[' + name + ']';\n    }\n    if (name === 'id' && (0, _utilities.isValidCSSIdentifier)(value)) {\n      return '#' + value;\n    }\n    return '[' + name + '=\"' + value + '\"]';\n  }).join('');\n};\n\n/**\n * Convert classes to CSS selector\n * \n * @param {Array.<string>} classes \n * @returns {string}\n */\nvar classesToSelector = exports.classesToSelector = function classesToSelector(classes) {\n  return classes.map(function (c) {\n    return (0, _utilities.isValidCSSIdentifier)(c) ? '.' + c : '[class~=\"' + c + '\"]';\n  }).join('');\n};\n\n/**\n * Convert pseudo selectors to CSS selector\n * \n * @param {Array.<string>} pseudo \n * @returns {string}\n */\nvar pseudoToSelector = exports.pseudoToSelector = function pseudoToSelector(pseudo) {\n  return pseudo.length ? ':' + pseudo.join(':') : '';\n};\n\n/**\n * Convert pattern to CSS selector\n * \n * @param {Pattern} pattern \n * @returns {string}\n */\nvar patternToSelector = exports.patternToSelector = function patternToSelector(pattern) {\n  var relates = pattern.relates,\n      tag = pattern.tag,\n      attributes = pattern.attributes,\n      classes = pattern.classes,\n      pseudo = pattern.pseudo;\n\n  var value = '' + (relates === 'child' ? '> ' : '') + (tag || '') + attributesToSelector(attributes) + classesToSelector(classes) + pseudoToSelector(pseudo);\n  return value;\n};\n\n/**\n * Converts path to string\n *\n * @param {Array.<Pattern>} path \n * @returns {string}\n */\nvar pathToSelector = exports.pathToSelector = function pathToSelector(path) {\n  return path.map(patternToSelector).join(' ');\n};\n\nvar convertEscaping = function convertEscaping(value) {\n  return value && value.replace(/\\\\([`\\\\/:?&!#$%^()[\\]{|}*+;,.<=>@~])/g, '$1').replace(/\\\\(['\"])/g, '$1$1').replace(/\\\\A /g, '\\n');\n};\n\n/**\n* Convert attributes to XPath string\n* \n* @param {Array.<{ name: string, value: string? }>} attributes \n* @returns {string}\n*/\nvar attributesToXPath = exports.attributesToXPath = function attributesToXPath(attributes) {\n  return attributes.map(function (_ref2) {\n    var name = _ref2.name,\n        value = _ref2.value;\n\n    if (value === null) {\n      return '[@' + name + ']';\n    }\n    return '[@' + name + '=\"' + convertEscaping(value) + '\"]';\n  }).join('');\n};\n\n/**\n* Convert classes to XPath string\n* \n* @param {Array.<string>} classes \n* @returns {string}\n*/\nvar classesToXPath = exports.classesToXPath = function classesToXPath(classes) {\n  return classes.map(function (c) {\n    return '[contains(concat(\" \",normalize-space(@class),\" \"),\" ' + c + ' \")]';\n  }).join('');\n};\n\n/**\n* Convert pseudo selectors to XPath string\n* \n* @param {Array.<string>} pseudo \n* @returns {string}\n*/\nvar pseudoToXPath = exports.pseudoToXPath = function pseudoToXPath(pseudo) {\n  return pseudo.map(function (p) {\n    var match = p.match(/^(nth-child|nth-of-type|contains)\\((.+)\\)$/);\n    if (!match) {\n      return '';\n    }\n\n    switch (match[1]) {\n      case 'nth-child':\n        return '[(count(preceding-sibling::*)+1) = ' + match[2] + ']';\n\n      case 'nth-of-type':\n        return '[' + match[2] + ']';\n\n      case 'contains':\n        return '[contains(text(),' + match[2] + ')]';\n\n      default:\n        return '';\n    }\n  }).join('');\n};\n\n/**\n* Convert pattern to XPath string\n* \n* @param {Pattern} pattern \n* @returns {string}\n*/\nvar patternToXPath = exports.patternToXPath = function patternToXPath(pattern) {\n  var relates = pattern.relates,\n      tag = pattern.tag,\n      attributes = pattern.attributes,\n      classes = pattern.classes,\n      pseudo = pattern.pseudo,\n      descendants = pattern.descendants;\n\n  var value = '' + (relates === 'child' ? '/' : '//') + (tag || '*') + attributesToXPath(attributes) + classesToXPath(classes) + pseudoToXPath(pseudo) + descendantsToXPath(descendants);\n  return value;\n};\n\n/**\n* Converts path to XPath string\n*\n* @param {Array.<Pattern>} path \n* @returns {string}\n*/\nvar pathToXPath = exports.pathToXPath = function pathToXPath(path) {\n  return '.' + path.map(patternToXPath).join('');\n};\n\n/**\n* Convert child selectors to XPath string\n* \n* @param {Array.<Array.<Pattern>>} children \n* @returns {string}\n*/\nvar descendantsToXPath = exports.descendantsToXPath = function descendantsToXPath(children) {\n  return children.length ? '[' + children.map(pathToXPath).join('][') + ']' : '';\n};\n\nvar toString = {\n  'css': {\n    attributes: attributesToSelector,\n    classes: classesToSelector,\n    pseudo: pseudoToSelector,\n    pattern: patternToSelector,\n    path: pathToSelector\n  },\n  'xpath': {\n    attributes: attributesToXPath,\n    classes: classesToXPath,\n    pseudo: pseudoToXPath,\n    pattern: patternToXPath,\n    path: pathToXPath\n  },\n  'jquery': {}\n};\n\ntoString.jquery = toString.css;\ntoString[0] = toString.css;\ntoString[1] = toString.xpath;\n\n/**\n * @typedef  {Object} ToStringApi\n * @property {(attributes: Array.<{ name: string, value: string? }>) => string} attributes\n * @property {(classes: Array.<string>) => string}  classes\n * @property {(pseudo: Array.<string>) => string}   pseudo\n * @property {(pattern: Pattern) => string}         pattern\n * @property {(path: Array.<Pattern>) => string}    path\n */\n\n/**\n * \n * @param {Options} options \n * @returns {ToStringApi}\n */\nvar getToString = exports.getToString = function getToString() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return toString[options.format || 'css'];\n};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// import Sizzle from 'sizzle'\nvar Sizzle = void 0;\n\n/**\n * Select element using jQuery\n * @param  {string}         selector\n * @param  {HTMLElement}    parent\n * @return Array.<HTMLElement>\n */\nvar selectJQuery = function selectJQuery(selector) {\n  var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (!Sizzle) {\n    Sizzle = __webpack_require__(7);\n  }\n  return Sizzle(selector, parent || document);\n};\n\n/**\n * Select element using XPath\n * @param  {string}         selector\n * @param  {HTMLElement}    parent\n * @return Array.<HTMLElement>\n */\nvar selectXPath = function selectXPath(selector) {\n  var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  parent = parent || document;\n  var doc = parent;\n  while (doc.parentNode) {\n    doc = doc.parentNode;\n  }\n  if (doc !== parent && !selector.startsWith('.')) {\n    selector = '.' + selector;\n  }\n  var iterator = doc.evaluate(selector, parent, null, 0);\n  var elements = [];\n  var element;\n  while (element = iterator.iterateNext()) {\n    elements.push(element);\n  }\n  return elements;\n};\n\n/**\n * Select element using CSS\n * @param  {string}         selector\n * @param  {HTMLElement}    parent\n * @return Array.<HTMLElement>\n */\nvar selectCSS = function selectCSS(selector) {\n  var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (parent || document).querySelectorAll(selector);\n};\n\nvar select = {\n  'css': selectCSS,\n  'xpath': selectXPath,\n  'jquery': selectJQuery\n};\n\nselect[0] = select.css;\nselect[1] = select.xpath;\n\n/**\n* \n* @param {Options} options \n* @returns {(selector: string, parent: HTMLElement) => Array.<HTMLElement>}\n*/\nvar getSelect = exports.getSelect = function getSelect() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (selector, parent) {\n    try {\n      return select[options.format || 'css'](selector, parent || options.root);\n    } catch (err) {\n      return [];\n    }\n  };\n};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getCommonProperties = exports.getCommonAncestor = undefined;\n\nvar _match = __webpack_require__(1);\n\nvar _utilities = __webpack_require__(0);\n\n/**\n * # Common\n *\n * Process collections for similarities.\n */\n\n/**\n * @typedef {import('./select').Options} Options\n */\n\n/**\n * Find the last common ancestor of elements\n *\n * @param  {Array.<HTMLElement>} elements  - [description]\n * @param  {Options}              options  - [description]\n * @return {HTMLElement}                   - [description]\n */\nvar getCommonAncestor = exports.getCommonAncestor = function getCommonAncestor(elements) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$root = options.root,\n      root = _options$root === undefined ? document : _options$root;\n\n\n  var ancestors = [];\n\n  elements.forEach(function (element, index) {\n    var parents = [];\n    while (element !== root) {\n      element = element.parentNode;\n      parents.unshift(element);\n    }\n    ancestors[index] = parents;\n  });\n\n  ancestors.sort(function (curr, next) {\n    return curr.length - next.length;\n  });\n\n  var shallowAncestor = ancestors.shift();\n\n  var ancestor = null;\n\n  var _loop = function _loop() {\n    var parent = shallowAncestor[i];\n    var missing = ancestors.some(function (otherParents) {\n      return !otherParents.some(function (otherParent) {\n        return otherParent === parent;\n      });\n    });\n\n    if (missing) {\n      // TODO: find similar sub-parents, not the top root, e.g. sharing a class selector\n      return 'break';\n    }\n\n    ancestor = parent;\n  };\n\n  for (var i = 0, l = shallowAncestor.length; i < l; i++) {\n    var _ret = _loop();\n\n    if (_ret === 'break') break;\n  }\n\n  return ancestor;\n};\n\n/**\n * Get a set of common properties of elements\n *\n * @param  {Array.<HTMLElement>} elements - [description]\n * @return {Object}                       - [description]\n */\nvar getCommonProperties = exports.getCommonProperties = function getCommonProperties(elements) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$ignore = options.ignore,\n      ignore = _options$ignore === undefined ? {} : _options$ignore;\n\n\n  var commonProperties = {\n    classes: [],\n    attributes: {},\n    tag: null\n  };\n\n  elements.forEach(function (element) {\n    var commonClasses = commonProperties.classes,\n        commonAttributes = commonProperties.attributes,\n        commonTag = commonProperties.tag;\n\n    // ~ classes\n\n    if (commonClasses !== undefined) {\n      var classes = element.getAttribute('class');\n      if (classes) {\n        classes = classes.trim().split(' ').filter(function (cls) {\n          return !ignore.class || !ignore.class(cls);\n        });\n        if (!commonClasses.length) {\n          commonProperties.classes = classes;\n        } else {\n          commonClasses = commonClasses.filter(function (entry) {\n            return classes.some(function (name) {\n              return name === entry;\n            });\n          });\n          if (commonClasses.length) {\n            commonProperties.classes = commonClasses;\n          } else {\n            delete commonProperties.classes;\n          }\n        }\n      } else {\n        delete commonProperties.classes;\n      }\n    }\n\n    // ~ attributes\n    if (commonAttributes !== undefined) {\n      var elementAttributes = element.attributes;\n      var attributes = Object.keys(elementAttributes).reduce(function (attributes, key) {\n        var attribute = elementAttributes[key];\n        var attributeName = (0, _utilities.escapeValue)(attribute && attribute.name);\n        var attributeValue = (0, _utilities.escapeValue)(attribute && attribute.value);\n        var useNamedIgnore = attributeName !== 'class';\n        var currentIgnore = useNamedIgnore && ignore[attributeName] || ignore.attribute;\n        var currentDefaultIgnore = useNamedIgnore && _match.defaultIgnore[attributeName] || _match.defaultIgnore.attribute;\n        if (attribute && attributeName !== 'class' && !(0, _match.checkIgnore)(currentIgnore, attributeName, attributeValue, currentDefaultIgnore)) {\n          attributes[attributeName] = attribute.value;\n        }\n        return attributes;\n      }, {});\n\n      var attributesNames = Object.keys(attributes);\n      var commonAttributesNames = Object.keys(commonAttributes);\n\n      if (attributesNames.length) {\n        if (!commonAttributesNames.length) {\n          commonProperties.attributes = attributes;\n        } else {\n          commonAttributes = commonAttributesNames.reduce(function (nextCommonAttributes, name) {\n            var value = commonAttributes[name];\n            if (value === attributes[name]) {\n              nextCommonAttributes[name] = value;\n            }\n            return nextCommonAttributes;\n          }, {});\n          if (Object.keys(commonAttributes).length) {\n            commonProperties.attributes = commonAttributes;\n          } else {\n            delete commonProperties.attributes;\n          }\n        }\n      } else {\n        delete commonProperties.attributes;\n      }\n    }\n\n    // ~ tag\n    if (commonTag !== undefined) {\n      var tag = element.tagName.toLowerCase();\n      if (!commonTag) {\n        commonProperties.tag = tag;\n      } else if (tag !== commonTag) {\n        delete commonProperties.tag;\n      }\n    }\n  });\n\n  return commonProperties;\n};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compareResults = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.default = optimize;\n\nvar _selector = __webpack_require__(3);\n\nvar _pattern2 = __webpack_require__(2);\n\nvar _utilities = __webpack_require__(0);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**\n                                                                                                                                                                                                     * # Optimize\n                                                                                                                                                                                                     *\n                                                                                                                                                                                                     * 1.) Improve efficiency through shorter selectors by removing redundancy\n                                                                                                                                                                                                     * 2.) Improve robustness through selector transformation\n                                                                                                                                                                                                     */\n\n/**\n * @typedef {import('./select').Options} Options\n * @typedef {import('./pattern').Pattern} Pattern\n * @typedef {import('./pattern').ToStringApi} Pattern\n */\n\n/**\n * Apply different optimization techniques\n *\n * @param  {Array.<Pattern>}                 path   - [description]\n * @param  {HTMLElement|Array.<HTMLElement>} element    - [description]\n * @param  {Options}                         [options]  - [description]\n * @return {Array.<Pattern>}                            - [description]\n */\nfunction optimize(path, elements) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (path.length === 0) {\n    return [];\n  }\n\n  if (path[0].relates === 'child') {\n    path[0].relates = undefined;\n  }\n\n  // convert single entry and NodeList\n  if (!Array.isArray(elements)) {\n    elements = !elements.length ? [elements] : (0, _utilities.convertNodeList)(elements);\n  }\n\n  if (!elements.length || elements.some(function (element) {\n    return element.nodeType !== 1;\n  })) {\n    throw new Error('Invalid input - to compare HTMLElements its necessary to provide a reference of the selected node(s)! (missing \"elements\")');\n  }\n\n  var select = (0, _selector.getSelect)(options);\n  var toString = (0, _pattern2.getToString)(options);\n\n  if (path.length === 1) {\n    return [optimizePart([], path[0], [], elements, select, toString)];\n  }\n\n  var endOptimized = false;\n  if (path[path.length - 1].relates === 'child') {\n    path[path.length - 1] = optimizePart(path.slice(0, -1), path[path.length - 1], [], elements, select, toString);\n    endOptimized = true;\n  }\n\n  path = [].concat(_toConsumableArray(path));\n  var shortened = [path.pop()];\n\n  var _loop = function _loop() {\n    var current = path.pop();\n    var matches = select(toString.path([].concat(_toConsumableArray(path), shortened)));\n    var hasSameResult = matches.length === elements.length && elements.every(function (element, i) {\n      return element === matches[i];\n    });\n    if (!hasSameResult) {\n      shortened.unshift(optimizePart(path, current, shortened, elements, select, toString));\n    }\n  };\n\n  while (path.length > 1) {\n    _loop();\n  }\n  shortened.unshift(path[0]);\n  path = shortened;\n\n  // optimize start + end\n  path[0] = optimizePart([], path[0], path.slice(1), elements, select, toString);\n  if (!endOptimized) {\n    path[path.length - 1] = optimizePart(path.slice(0, -1), path[path.length - 1], [], elements, select, toString);\n  }\n\n  return path;\n}\n\n/**\n * Optimize :contains\n *\n * @param  {Array.<Pattern>}     pre      - [description]\n * @param  {Pattern}             current  - [description]\n * @param  {Array.<Pattern>}     post     - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @param  {ToStringApi}         toString - [description]\n * @return {Pattern}                      - [description]\n */\nvar optimizeText = function optimizeText(pre, current, post, elements, select, toString) {\n  var _partition = (0, _utilities.partition)(current.pseudo, function (item) {\n    return item.startsWith('contains');\n  }),\n      _partition2 = _slicedToArray(_partition, 2),\n      contains = _partition2[0],\n      other = _partition2[1];\n\n  if (contains.length > 0 && post.length) {\n    var base = _extends({}, current, { pseudo: [].concat(_toConsumableArray(other), _toConsumableArray(contains)) });\n    while (base.pseudo.length > other.length) {\n      var optimized = base.pseudo.slice(0, -1);\n      if (!compareResults(select(toString.path([].concat(_toConsumableArray(pre), [_extends({}, base, { pseudo: optimized })], _toConsumableArray(post)))), elements)) {\n        break;\n      }\n      base.pseudo = optimized;\n    }\n    return base;\n  }\n  return current;\n};\n\n/**\n * Optimize attributes\n *\n * @param  {Array.<Pattern>}     pre      - [description]\n * @param  {Pattern}             current  - [description]\n * @param  {Array.<Pattern>}     post     - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @param  {ToStringApi}         toString - [description]\n * @return {Pattern}                      - [description]\n */\nvar optimizeAttributes = function optimizeAttributes(pre, current, post, elements, select, toString) {\n  // reduce attributes: first try without value, then removing completely\n  if (current.attributes.length > 0) {\n    var attributes = [].concat(_toConsumableArray(current.attributes));\n\n    var simplify = function simplify(original, getSimplified) {\n      var i = original.length - 1;\n      while (i >= 0) {\n        var _attributes = getSimplified(original, i);\n        if (!compareResults(select(toString.path([].concat(_toConsumableArray(pre), [_extends({}, current, { attributes: _attributes })], _toConsumableArray(post)))), elements)) {\n          break;\n        }\n        i--;\n        original = _attributes;\n      }\n      return original;\n    };\n\n    var simplified = simplify(attributes, function (attributes, i) {\n      var name = attributes[i].name;\n\n      if (name === 'id') {\n        return attributes;\n      }\n      return [].concat(_toConsumableArray(attributes.slice(0, i)), [{ name: name, value: null }], _toConsumableArray(attributes.slice(i + 1)));\n    });\n    return _extends({}, current, { attributes: simplify(simplified, function (attributes) {\n        return attributes.slice(0, -1);\n      }) });\n  }\n  return current;\n};\n\n/**\n * Optimize descendant\n *\n * @param  {Array.<Pattern>}     pre      - [description]\n * @param  {Pattern}             current  - [description]\n * @param  {Array.<Pattern>}     post     - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @param  {ToStringApi}         toString - [description]\n * @return {Pattern}                      - [description]\n */\nvar optimizeDescendant = function optimizeDescendant(pre, current, post, elements, select, toString) {\n  // robustness: descendant instead child (heuristic)\n  if (current.relates === 'child') {\n    var descendant = _extends({}, current, { relates: undefined });\n    var _matches = select(toString.path([].concat(_toConsumableArray(pre), [descendant], _toConsumableArray(post))));\n    if (compareResults(_matches, elements)) {\n      return descendant;\n    }\n  }\n  return current;\n};\n\n/**\n * Optimize recursive descendants\n * \n * @param  {Array.<Pattern>}     pre      - [description]\n * @param  {Pattern}             current  - [description]\n * @param  {Array.<Pattern>}     post     - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @param  {ToStringApi}         toString - [description]\n * @return {Pattern}                      - [description]\n */\nvar optimizeRecursiveDescendants = function optimizeRecursiveDescendants(pre, current, post, elements, select, toString) {\n  if (current.descendants.length > 0 && post.length) {\n    var base = _extends({}, current, { descendants: [].concat(_toConsumableArray(current.descendants)) });\n    while (base.descendants.length > 0) {\n      var optimized = base.descendants.slice(0, -1);\n      if (!compareResults(select(toString.path([].concat(_toConsumableArray(pre), [_extends({}, base, { descendants: optimized })], _toConsumableArray(post)))), elements)) {\n        break;\n      }\n      base.descendants = optimized;\n    }\n    return base;\n  }\n  return current;\n};\n\n/**\n * Optimize nth of type\n *\n * @param  {Array.<Pattern>}     pre      - [description]\n * @param  {Pattern}             current  - [description]\n * @param  {Array.<Pattern>}     post     - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @param  {ToStringApi}         toString - [description]\n * @return {Pattern}                      - [description]\n */\nvar optimizeNthOfType = function optimizeNthOfType(pre, current, post, elements, select, toString) {\n  var i = current.pseudo.findIndex(function (item) {\n    return item.startsWith('nth-child');\n  });\n  // robustness: 'nth-of-type' instead 'nth-child' (heuristic)\n  if (i >= 0) {\n    // TODO: consider complete coverage of 'nth-of-type' replacement\n    var type = current.pseudo[i].replace(/^nth-child/, 'nth-of-type');\n    var nthOfType = _extends({}, current, { pseudo: [].concat(_toConsumableArray(current.pseudo.slice(0, i)), [type], _toConsumableArray(current.pseudo.slice(i + 1))) });\n    var pattern = toString.path([].concat(_toConsumableArray(pre), [nthOfType], _toConsumableArray(post)));\n    var _matches2 = select(pattern);\n    if (compareResults(_matches2, elements)) {\n      return nthOfType;\n    }\n  }\n  return current;\n};\n\n/**\n * Optimize classes\n *\n * @param  {Array.<Pattern>}     pre      - [description]\n * @param  {Pattern}             current  - [description]\n * @param  {Array.<Pattern>}     post     - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @param  {ToStringApi}         toString - [description]\n * @return {Pattern}                      - [description]\n */\nvar optimizeClasses = function optimizeClasses(pre, current, post, elements, select, toString) {\n  // efficiency: combinations of classname (partial permutations)\n  if (current.classes.length > 1) {\n    var optimized = current.classes.slice().sort(function (curr, next) {\n      return curr.length - next.length;\n    });\n\n    while (optimized.length > 1) {\n      optimized.shift();\n      var _pattern = toString.path([].concat(_toConsumableArray(pre), [_extends({}, current, { classes: optimized })], _toConsumableArray(post)));\n      if (!compareResults(select(_pattern), elements)) {\n        break;\n      }\n      current.classes = optimized;\n    }\n\n    optimized = current.classes;\n\n    if (optimized.length > 2) {\n      var base = (0, _pattern2.createPattern)({ classes: optimized });\n      var references = select(toString.path([].concat(_toConsumableArray(pre), [base])));\n\n      var _loop2 = function _loop2() {\n        var reference = references[i];\n        if (elements.some(function (element) {\n          return reference.contains(element);\n        })) {\n          // TODO:\n          // - check using attributes + regard excludes\n          var description = (0, _pattern2.createPattern)({ tag: reference.tagName });\n          pattern = toString.path([].concat(_toConsumableArray(pre), [description], _toConsumableArray(post)));\n          matches = select(pattern);\n\n          if (compareResults(matches, elements)) {\n            current = description;\n          }\n          return 'break';\n        }\n      };\n\n      for (var i = 0; i < references.length; i++) {\n        var pattern;\n        var matches;\n\n        var _ret2 = _loop2();\n\n        if (_ret2 === 'break') break;\n      }\n    }\n  }\n  return current;\n};\n\nvar optimizers = [optimizeText, optimizeAttributes, optimizeDescendant, optimizeRecursiveDescendants, optimizeNthOfType, optimizeClasses];\n\n/**\n * Improve a chunk of the selector\n *\n * @param  {Array.<Pattern>}     pre      - [description]\n * @param  {Pattern}             current  - [description]\n * @param  {Array.<Pattern>}     post     - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @param  {ToStringApi}         toString - [description]\n * @return {Pattern}                      - [description]\n */\nvar optimizePart = function optimizePart(pre, current, post, elements, select, toString) {\n  return optimizers.reduce(function (acc, optimizer) {\n    return optimizer(pre, acc, post, elements, select, toString);\n  }, current);\n};\n\n/**\n * Evaluate matches with expected elements\n *\n * @param  {Array.<HTMLElement>} matches  - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @return {Boolean}                      - [description]\n */\nvar compareResults = exports.compareResults = function compareResults(matches, elements) {\n  var length = matches.length;\n\n  return length === elements.length && elements.every(function (element) {\n    for (var i = 0; i < length; i++) {\n      if (matches[i] === element) {\n        return true;\n      }\n    }\n    return false;\n  });\n};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getMultiSelectorPath = exports.getSingleSelectorPath = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /**\n                                                                                                                                                                                                                                                                               * # Select\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               * Construct a unique CSS query selector to access the selected DOM element(s).\n                                                                                                                                                                                                                                                                               * For longevity it applies different matching and optimization strategies.\n                                                                                                                                                                                                                                                                               */\n\n\nexports.default = getQuerySelector;\n\nvar _match = __webpack_require__(1);\n\nvar _match2 = _interopRequireDefault(_match);\n\nvar _optimize = __webpack_require__(5);\n\nvar _optimize2 = _interopRequireDefault(_optimize);\n\nvar _utilities = __webpack_require__(0);\n\nvar _common = __webpack_require__(4);\n\nvar _selector = __webpack_require__(3);\n\nvar _pattern = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * @typedef  {Object} Options\n * @property {HTMLElement} [root]                     Optionally specify the root element\n * @property {function | Array.<HTMLElement>} [skip]  Specify elements to skip\n * @property {Array.<string>} [priority]              Order of attribute processing\n * @property {Object<string, function | number | string | boolean} [ignore] Define patterns which shouldn't be included\n * @property {('css'|'xpath'|'jquery')} [format]      Output format    \n */\n\n/**\n * @typedef {import('./pattern').Pattern} Pattern\n */\n\n/**\n * Get a selector for the provided element\n *\n * @param  {HTMLElement} element   - [description]\n * @param  {Options}     [options] - [description]\n * @return {Array.<Pattern>}       - [description]\n */\nvar getSingleSelectorPath = exports.getSingleSelectorPath = function getSingleSelectorPath(element) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n  if (element.nodeType === 3) {\n    element = element.parentNode;\n  }\n\n  if (element.nodeType !== 1) {\n    throw new Error('Invalid input - only HTMLElements or representations of them are supported! (not \"' + (typeof element === 'undefined' ? 'undefined' : _typeof(element)) + '\")');\n  }\n\n  var path = (0, _match2.default)(element, options);\n  var optimizedPath = (0, _optimize2.default)(path, element, options);\n\n  // debug\n  // console.log(`\n  //   selector:  ${path}\n  //   optimized: ${optimizedPath}\n  // `)\n\n  return optimizedPath;\n};\n\n/**\n * Get a selector to match multiple descendants from an ancestor\n *\n * @param  {Array.<HTMLElement>|NodeList} elements   - [description]\n * @param  {Options}                      [options]  - [description]\n * @return {Array.<Pattern>}                         - [description]\n */\nvar getMultiSelectorPath = exports.getMultiSelectorPath = function getMultiSelectorPath(elements) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n  if (!Array.isArray(elements)) {\n    elements = (0, _utilities.convertNodeList)(elements);\n  }\n\n  if (elements.some(function (element) {\n    return element.nodeType !== 1;\n  })) {\n    throw new Error('Invalid input - only an Array of HTMLElements or representations of them is supported!');\n  }\n\n  var select = (0, _selector.getSelect)(options);\n  var toString = (0, _pattern.getToString)(options);\n\n  var ancestor = (0, _common.getCommonAncestor)(elements, options);\n  var ancestorPath = (0, _match2.default)(ancestor, options);\n\n  // TODO: consider usage of multiple selectors + parent-child relation + check for part redundancy\n  var commonPath = getCommonPath(elements, options);\n  var descendantPattern = commonPath[0];\n\n  var selectorPath = (0, _optimize2.default)([].concat(_toConsumableArray(ancestorPath), [descendantPattern]), elements, options);\n  var selectorMatches = (0, _utilities.convertNodeList)(select(toString.path(selectorPath)));\n\n  if (!elements.every(function (element) {\n    return selectorMatches.some(function (entry) {\n      return entry === element;\n    });\n  })) {\n    // TODO: cluster matches to split into similar groups for sub selections\n    console.warn('\\n      The selected elements can\\'t be efficiently mapped.\\n      Its probably best to use multiple single selectors instead!\\n    ');\n    return elements;\n  }\n\n  return selectorPath;\n};\n\n/**\n * Get selectors to describe a set of elements\n *\n * @param  {Array.<HTMLElement>} elements  - [description]\n * @return {Array.<Pattern>}               - [description]\n */\nvar getCommonPath = function getCommonPath(elements, options) {\n  var _getCommonProperties = (0, _common.getCommonProperties)(elements, options),\n      classes = _getCommonProperties.classes,\n      attributes = _getCommonProperties.attributes,\n      tag = _getCommonProperties.tag;\n\n  return [(0, _pattern.createPattern)({\n    tag: tag,\n    classes: classes || [],\n    attributes: attributes ? Object.keys(attributes).map(function (name) {\n      return {\n        name: (0, _utilities.escapeValue)(name),\n        value: (0, _utilities.escapeValue)(attributes[name])\n      };\n    }) : []\n  })];\n};\n\n/**\n * Choose action depending on the input (multiple/single)\n *\n * NOTE: extended detection is used for special cases like the <select> element with <options>\n *\n * @param  {HTMLElement|NodeList|Array.<HTMLElement>} input     - [description]\n * @param  {Options}                                  [options] - [description]\n * @return {string}                                             - [description]\n */\nfunction getQuerySelector(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var path = input.length && !input.name ? getMultiSelectorPath(input, options) : getSingleSelectorPath(input, options);\n\n  if (Array.isArray(path) && path.length > 0 && path[0] instanceof HTMLElement) {\n    return path.map(function (entry) {\n      return getQuerySelector(entry, options);\n    }).join(',');\n  }\n  return (0, _pattern.getToString)(options).path(path);\n}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n/*!\n * Sizzle CSS Selector Engine v2.3.6\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://js.foundation/\n *\n * Date: 2021-02-16\n */\n(function (window) {\n\tvar i,\n\t    support,\n\t    Expr,\n\t    getText,\n\t    isXML,\n\t    tokenize,\n\t    compile,\n\t    select,\n\t    outermostContext,\n\t    sortInput,\n\t    hasDuplicate,\n\n\n\t// Local document vars\n\tsetDocument,\n\t    document,\n\t    docElem,\n\t    documentIsHTML,\n\t    rbuggyQSA,\n\t    rbuggyMatches,\n\t    matches,\n\t    contains,\n\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\t    preferredDoc = window.document,\n\t    dirruns = 0,\n\t    done = 0,\n\t    classCache = createCache(),\n\t    tokenCache = createCache(),\n\t    compilerCache = createCache(),\n\t    nonnativeSelectorCache = createCache(),\n\t    sortOrder = function sortOrder(a, b) {\n\t\tif (a === b) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\n\t// Instance methods\n\thasOwn = {}.hasOwnProperty,\n\t    arr = [],\n\t    pop = arr.pop,\n\t    pushNative = arr.push,\n\t    push = arr.push,\n\t    slice = arr.slice,\n\n\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function indexOf(list, elem) {\n\t\tvar i = 0,\n\t\t    len = list.length;\n\t\tfor (; i < len; i++) {\n\t\t\tif (list[i] === elem) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\t    booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|\" + \"ismap|loop|multiple|open|readonly|required|scoped\",\n\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\n\t// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n\tidentifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\n\t// Operator (capture 2)\n\t\"*([*^$|!~]?=)\" + whitespace +\n\n\t// \"Attribute values must be CSS identifiers [capture 5]\n\t// or strings [capture 3 or capture 4]\"\n\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n\t    pseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\n\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\n\t// 2. simple (capture 6)\n\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\n\t// 3. anything else (capture 2)\n\t\".*\" + \")\\\\)|)\",\n\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n\t    rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n\t    rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n\t    rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n\t    rdescend = new RegExp(whitespace + \"|>\"),\n\t    rpseudo = new RegExp(pseudos),\n\t    ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n\t    matchExpr = {\n\t\t\"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n\t\t\"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n\t\t\"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n\t\t\"ATTR\": new RegExp(\"^\" + attributes),\n\t\t\"PSEUDO\": new RegExp(\"^\" + pseudos),\n\t\t\"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n\t\t\"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n\t},\n\t    rhtml = /HTML$/i,\n\t    rinputs = /^(?:input|select|textarea|button)$/i,\n\t    rheader = /^h\\d$/i,\n\t    rnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\t    rsibling = /[+~]/,\n\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\"),\n\t    funescape = function funescape(escape, nonHex) {\n\t\tvar high = \"0x\" + escape.slice(1) - 0x10000;\n\n\t\treturn nonHex ?\n\n\t\t// Strip the backslash prefix from a non-hex escape sequence\n\t\tnonHex :\n\n\t\t// Replace a hexadecimal escape sequence with the encoded Unicode code point\n\t\t// Support: IE <=11+\n\t\t// For values outside the Basic Multilingual Plane (BMP), manually construct a\n\t\t// surrogate pair\n\t\thigh < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n\t},\n\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\t    fcssescape = function fcssescape(ch, asCodePoint) {\n\t\tif (asCodePoint) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif (ch === \"\\0\") {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function unloadHandler() {\n\t\tsetDocument();\n\t},\n\t    inDisabledFieldset = addCombinator(function (elem) {\n\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n\t}, { dir: \"parentNode\", next: \"legend\" });\n\n\t// Optimize for push.apply( _, NodeList )\n\ttry {\n\t\tpush.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);\n\n\t\t// Support: Android<4.0\n\t\t// Detect silently failing push.apply\n\t\t// eslint-disable-next-line no-unused-expressions\n\t\tarr[preferredDoc.childNodes.length].nodeType;\n\t} catch (e) {\n\t\tpush = { apply: arr.length ?\n\n\t\t\t// Leverage slice if possible\n\t\t\tfunction (target, els) {\n\t\t\t\tpushNative.apply(target, slice.call(els));\n\t\t\t} :\n\n\t\t\t// Support: IE<9\n\t\t\t// Otherwise append directly\n\t\t\tfunction (target, els) {\n\t\t\t\tvar j = target.length,\n\t\t\t\t    i = 0;\n\n\t\t\t\t// Can't trust NodeList.length\n\t\t\t\twhile (target[j++] = els[i++]) {}\n\t\t\t\ttarget.length = j - 1;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction Sizzle(selector, context, results, seed) {\n\t\tvar m,\n\t\t    i,\n\t\t    elem,\n\t\t    nid,\n\t\t    match,\n\t\t    groups,\n\t\t    newSelector,\n\t\t    newContext = context && context.ownerDocument,\n\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\t\tresults = results || [];\n\n\t\t// Return early from calls with invalid selector or context\n\t\tif (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n\n\t\t\treturn results;\n\t\t}\n\n\t\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\t\tif (!seed) {\n\t\t\tsetDocument(context);\n\t\t\tcontext = context || document;\n\n\t\t\tif (documentIsHTML) {\n\n\t\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\t\tif (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n\n\t\t\t\t\t// ID selector\n\t\t\t\t\tif (m = match[1]) {\n\n\t\t\t\t\t\t// Document context\n\t\t\t\t\t\tif (nodeType === 9) {\n\t\t\t\t\t\t\tif (elem = context.getElementById(m)) {\n\n\t\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\t\tif (elem.id === m) {\n\t\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Element context\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n\n\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Type selector\n\t\t\t\t\t} else if (match[2]) {\n\t\t\t\t\t\tpush.apply(results, context.getElementsByTagName(selector));\n\t\t\t\t\t\treturn results;\n\n\t\t\t\t\t\t// Class selector\n\t\t\t\t\t} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n\n\t\t\t\t\t\tpush.apply(results, context.getElementsByClassName(m));\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Take advantage of querySelectorAll\n\t\t\t\tif (support.qsa && !nonnativeSelectorCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (\n\n\t\t\t\t// Support: IE 8 only\n\t\t\t\t// Exclude object elements\n\t\t\t\tnodeType !== 1 || context.nodeName.toLowerCase() !== \"object\")) {\n\n\t\t\t\t\tnewSelector = selector;\n\t\t\t\t\tnewContext = context;\n\n\t\t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n\t\t\t\t\t// descendant combinators, which is not what we want.\n\t\t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n\t\t\t\t\t// list with an ID selector referencing the scope context.\n\t\t\t\t\t// The technique has to be used as well when a leading combinator is used\n\t\t\t\t\t// as such selectors are not recognized by querySelectorAll.\n\t\t\t\t\t// Thanks to Andrew Dupont for this technique.\n\t\t\t\t\tif (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {\n\n\t\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\t\tnewContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n\n\t\t\t\t\t\t// We can use :scope instead of the ID hack if the browser\n\t\t\t\t\t\t// supports it & if we're not changing the context.\n\t\t\t\t\t\tif (newContext !== context || !support.scope) {\n\n\t\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\t\tif (nid = context.getAttribute(\"id\")) {\n\t\t\t\t\t\t\t\tnid = nid.replace(rcssescape, fcssescape);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontext.setAttribute(\"id\", nid = expando);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\t\tgroups = tokenize(selector);\n\t\t\t\t\t\ti = groups.length;\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tgroups[i] = (nid ? \"#\" + nid : \":scope\") + \" \" + toSelector(groups[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply(results, newContext.querySelectorAll(newSelector));\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch (qsaError) {\n\t\t\t\t\t\tnonnativeSelectorCache(selector, true);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (nid === expando) {\n\t\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// All others\n\t\treturn select(selector.replace(rtrim, \"$1\"), context, results, seed);\n\t}\n\n\t/**\n  * Create key-value caches of limited size\n  * @returns {function(string, object)} Returns the Object data after storing it on itself with\n  *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n  *\tdeleting the oldest entry\n  */\n\tfunction createCache() {\n\t\tvar keys = [];\n\n\t\tfunction cache(key, value) {\n\n\t\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\t\tif (keys.push(key + \" \") > Expr.cacheLength) {\n\n\t\t\t\t// Only keep the most recent entries\n\t\t\t\tdelete cache[keys.shift()];\n\t\t\t}\n\t\t\treturn cache[key + \" \"] = value;\n\t\t}\n\t\treturn cache;\n\t}\n\n\t/**\n  * Mark a function for special use by Sizzle\n  * @param {Function} fn The function to mark\n  */\n\tfunction markFunction(fn) {\n\t\tfn[expando] = true;\n\t\treturn fn;\n\t}\n\n\t/**\n  * Support testing using an element\n  * @param {Function} fn Passed the created element and returns a boolean result\n  */\n\tfunction assert(fn) {\n\t\tvar el = document.createElement(\"fieldset\");\n\n\t\ttry {\n\t\t\treturn !!fn(el);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t} finally {\n\n\t\t\t// Remove from its parent by default\n\t\t\tif (el.parentNode) {\n\t\t\t\tel.parentNode.removeChild(el);\n\t\t\t}\n\n\t\t\t// release memory in IE\n\t\t\tel = null;\n\t\t}\n\t}\n\n\t/**\n  * Adds the same handler for all of the specified attrs\n  * @param {String} attrs Pipe-separated list of attributes\n  * @param {Function} handler The method that will be applied\n  */\n\tfunction addHandle(attrs, handler) {\n\t\tvar arr = attrs.split(\"|\"),\n\t\t    i = arr.length;\n\n\t\twhile (i--) {\n\t\t\tExpr.attrHandle[arr[i]] = handler;\n\t\t}\n\t}\n\n\t/**\n  * Checks document order of two siblings\n  * @param {Element} a\n  * @param {Element} b\n  * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n  */\n\tfunction siblingCheck(a, b) {\n\t\tvar cur = b && a,\n\t\t    diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;\n\n\t\t// Use IE sourceIndex if available on both nodes\n\t\tif (diff) {\n\t\t\treturn diff;\n\t\t}\n\n\t\t// Check if b follows a\n\t\tif (cur) {\n\t\t\twhile (cur = cur.nextSibling) {\n\t\t\t\tif (cur === b) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn a ? 1 : -1;\n\t}\n\n\t/**\n  * Returns a function to use in pseudos for input types\n  * @param {String} type\n  */\n\tfunction createInputPseudo(type) {\n\t\treturn function (elem) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === type;\n\t\t};\n\t}\n\n\t/**\n  * Returns a function to use in pseudos for buttons\n  * @param {String} type\n  */\n\tfunction createButtonPseudo(type) {\n\t\treturn function (elem) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t\t};\n\t}\n\n\t/**\n  * Returns a function to use in pseudos for :enabled/:disabled\n  * @param {Boolean} disabled true for :disabled; false for :enabled\n  */\n\tfunction createDisabledPseudo(disabled) {\n\n\t\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\t\treturn function (elem) {\n\n\t\t\t// Only certain elements can match :enabled or :disabled\n\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\t\tif (\"form\" in elem) {\n\n\t\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t\t// * option elements in a disabled optgroup\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t\t// All such elements have a \"form\" property.\n\t\t\t\tif (elem.parentNode && elem.disabled === false) {\n\n\t\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\t\tif (\"label\" in elem) {\n\t\t\t\t\t\tif (\"label\" in elem.parentNode) {\n\t\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;\n\t\t\t\t}\n\n\t\t\t\treturn elem.disabled === disabled;\n\n\t\t\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t\t\t// even exist on them, let alone have a boolean value.\n\t\t\t} else if (\"label\" in elem) {\n\t\t\t\treturn elem.disabled === disabled;\n\t\t\t}\n\n\t\t\t// Remaining elements are neither :enabled nor :disabled\n\t\t\treturn false;\n\t\t};\n\t}\n\n\t/**\n  * Returns a function to use in pseudos for positionals\n  * @param {Function} fn\n  */\n\tfunction createPositionalPseudo(fn) {\n\t\treturn markFunction(function (argument) {\n\t\t\targument = +argument;\n\t\t\treturn markFunction(function (seed, matches) {\n\t\t\t\tvar j,\n\t\t\t\t    matchIndexes = fn([], seed.length, argument),\n\t\t\t\t    i = matchIndexes.length;\n\n\t\t\t\t// Match elements found at the specified indexes\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (seed[j = matchIndexes[i]]) {\n\t\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n  * Checks a node for validity as a Sizzle context\n  * @param {Element|Object=} context\n  * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n  */\n\tfunction testContext(context) {\n\t\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n\t}\n\n\t// Expose support vars for convenience\n\tsupport = Sizzle.support = {};\n\n\t/**\n  * Detects XML nodes\n  * @param {Element|Object} elem An element or a document\n  * @returns {Boolean} True iff elem is a non-HTML XML node\n  */\n\tisXML = Sizzle.isXML = function (elem) {\n\t\tvar namespace = elem && elem.namespaceURI,\n\t\t    docElem = elem && (elem.ownerDocument || elem).documentElement;\n\n\t\t// Support: IE <=8\n\t\t// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n\t\t// https://bugs.jquery.com/ticket/4833\n\t\treturn !rhtml.test(namespace || docElem && docElem.nodeName || \"HTML\");\n\t};\n\n\t/**\n  * Sets document-related variables once based on the current document\n  * @param {Element|Object} [doc] An element or document object to use to set the document\n  * @returns {Object} Returns the current document\n  */\n\tsetDocument = Sizzle.setDocument = function (node) {\n\t\tvar hasCompare,\n\t\t    subWindow,\n\t\t    doc = node ? node.ownerDocument || node : preferredDoc;\n\n\t\t// Return early if doc is invalid or already selected\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tif (doc == document || doc.nodeType !== 9 || !doc.documentElement) {\n\t\t\treturn document;\n\t\t}\n\n\t\t// Update global variables\n\t\tdocument = doc;\n\t\tdocElem = document.documentElement;\n\t\tdocumentIsHTML = !isXML(document);\n\n\t\t// Support: IE 9 - 11+, Edge 12 - 18+\n\t\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tif (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n\n\t\t\t// Support: IE 11, Edge\n\t\t\tif (subWindow.addEventListener) {\n\t\t\t\tsubWindow.addEventListener(\"unload\", unloadHandler, false);\n\n\t\t\t\t// Support: IE 9 - 10 only\n\t\t\t} else if (subWindow.attachEvent) {\n\t\t\t\tsubWindow.attachEvent(\"onunload\", unloadHandler);\n\t\t\t}\n\t\t}\n\n\t\t// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\n\t\t// Safari 4 - 5 only, Opera <=11.6 - 12.x only\n\t\t// IE/Edge & older browsers don't support the :scope pseudo-class.\n\t\t// Support: Safari 6.0 only\n\t\t// Safari 6.0 supports :scope but it's an alias of :root there.\n\t\tsupport.scope = assert(function (el) {\n\t\t\tdocElem.appendChild(el).appendChild(document.createElement(\"div\"));\n\t\t\treturn typeof el.querySelectorAll !== \"undefined\" && !el.querySelectorAll(\":scope fieldset div\").length;\n\t\t});\n\n\t\t/* Attributes\n  ---------------------------------------------------------------------- */\n\n\t\t// Support: IE<8\n\t\t// Verify that getAttribute really returns attributes and not properties\n\t\t// (excepting IE8 booleans)\n\t\tsupport.attributes = assert(function (el) {\n\t\t\tel.className = \"i\";\n\t\t\treturn !el.getAttribute(\"className\");\n\t\t});\n\n\t\t/* getElement(s)By*\n  ---------------------------------------------------------------------- */\n\n\t\t// Check if getElementsByTagName(\"*\") returns only elements\n\t\tsupport.getElementsByTagName = assert(function (el) {\n\t\t\tel.appendChild(document.createComment(\"\"));\n\t\t\treturn !el.getElementsByTagName(\"*\").length;\n\t\t});\n\n\t\t// Support: IE<9\n\t\tsupport.getElementsByClassName = rnative.test(document.getElementsByClassName);\n\n\t\t// Support: IE<10\n\t\t// Check if getElementById returns elements by name\n\t\t// The broken getElementById methods don't pick up programmatically-set names,\n\t\t// so use a roundabout getElementsByName test\n\t\tsupport.getById = assert(function (el) {\n\t\t\tdocElem.appendChild(el).id = expando;\n\t\t\treturn !document.getElementsByName || !document.getElementsByName(expando).length;\n\t\t});\n\n\t\t// ID filter and find\n\t\tif (support.getById) {\n\t\t\tExpr.filter[\"ID\"] = function (id) {\n\t\t\t\tvar attrId = id.replace(runescape, funescape);\n\t\t\t\treturn function (elem) {\n\t\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\t\tExpr.find[\"ID\"] = function (id, context) {\n\t\t\t\tif (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n\t\t\t\t\tvar elem = context.getElementById(id);\n\t\t\t\t\treturn elem ? [elem] : [];\n\t\t\t\t}\n\t\t\t};\n\t\t} else {\n\t\t\tExpr.filter[\"ID\"] = function (id) {\n\t\t\t\tvar attrId = id.replace(runescape, funescape);\n\t\t\t\treturn function (elem) {\n\t\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\t\t\treturn node && node.value === attrId;\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// Support: IE 6 - 7 only\n\t\t\t// getElementById is not reliable as a find shortcut\n\t\t\tExpr.find[\"ID\"] = function (id, context) {\n\t\t\t\tif (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n\t\t\t\t\tvar node,\n\t\t\t\t\t    i,\n\t\t\t\t\t    elems,\n\t\t\t\t\t    elem = context.getElementById(id);\n\n\t\t\t\t\tif (elem) {\n\n\t\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif (node && node.value === id) {\n\t\t\t\t\t\t\treturn [elem];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\t\telems = context.getElementsByName(id);\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile (elem = elems[i++]) {\n\t\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\t\tif (node && node.value === id) {\n\t\t\t\t\t\t\t\treturn [elem];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Tag\n\t\tExpr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n\t\t\tif (typeof context.getElementsByTagName !== \"undefined\") {\n\t\t\t\treturn context.getElementsByTagName(tag);\n\n\t\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if (support.qsa) {\n\t\t\t\treturn context.querySelectorAll(tag);\n\t\t\t}\n\t\t} : function (tag, context) {\n\t\t\tvar elem,\n\t\t\t    tmp = [],\n\t\t\t    i = 0,\n\n\n\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\tresults = context.getElementsByTagName(tag);\n\n\t\t\t// Filter out possible comments\n\t\t\tif (tag === \"*\") {\n\t\t\t\twhile (elem = results[i++]) {\n\t\t\t\t\tif (elem.nodeType === 1) {\n\t\t\t\t\t\ttmp.push(elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\t// Class\n\t\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n\t\t\tif (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n\t\t\t\treturn context.getElementsByClassName(className);\n\t\t\t}\n\t\t};\n\n\t\t/* QSA/matchesSelector\n  ---------------------------------------------------------------------- */\n\n\t\t// QSA and matchesSelector support\n\n\t\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\t\trbuggyMatches = [];\n\n\t\t// qSa(:focus) reports false when true (Chrome 21)\n\t\t// We allow this because of a bug in IE8/9 that throws an error\n\t\t// whenever `document.activeElement` is accessed on an iframe\n\t\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t\t// See https://bugs.jquery.com/ticket/13378\n\t\trbuggyQSA = [];\n\n\t\tif (support.qsa = rnative.test(document.querySelectorAll)) {\n\n\t\t\t// Build QSA regex\n\t\t\t// Regex strategy adopted from Diego Perini\n\t\t\tassert(function (el) {\n\n\t\t\t\tvar input;\n\n\t\t\t\t// Select is set to empty string on purpose\n\t\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t\t// setting a boolean content attribute,\n\t\t\t\t// since its presence should be enough\n\t\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\t\tdocElem.appendChild(el).innerHTML = \"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\";\n\n\t\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\t\tif (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n\t\t\t\t\trbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n\t\t\t\t}\n\n\t\t\t\t// Support: IE8\n\t\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\t\tif (!el.querySelectorAll(\"[selected]\").length) {\n\t\t\t\t\trbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n\t\t\t\t}\n\n\t\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\t\tif (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n\t\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 11+, Edge 15 - 18+\n\t\t\t\t// IE 11/Edge don't find elements on a `[name='']` query in some cases.\n\t\t\t\t// Adding a temporary attribute to the document before the selection works\n\t\t\t\t// around the issue.\n\t\t\t\t// Interestingly, IE 10 & older don't seem to have the issue.\n\t\t\t\tinput = document.createElement(\"input\");\n\t\t\t\tinput.setAttribute(\"name\", \"\");\n\t\t\t\tel.appendChild(input);\n\t\t\t\tif (!el.querySelectorAll(\"[name='']\").length) {\n\t\t\t\t\trbuggyQSA.push(\"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" + whitespace + \"*(?:''|\\\"\\\")\");\n\t\t\t\t}\n\n\t\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif (!el.querySelectorAll(\":checked\").length) {\n\t\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t\t}\n\n\t\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\t\tif (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n\t\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t\t}\n\n\t\t\t\t// Support: Firefox <=3.6 - 5 only\n\t\t\t\t// Old Firefox doesn't throw on a badly-escaped identifier.\n\t\t\t\tel.querySelectorAll(\"\\\\\\f\");\n\t\t\t\trbuggyQSA.push(\"[\\\\r\\\\n\\\\f]\");\n\t\t\t});\n\n\t\t\tassert(function (el) {\n\t\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" + \"<select disabled='disabled'><option/></select>\";\n\n\t\t\t\t// Support: Windows 8 Native Apps\n\t\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\t\tvar input = document.createElement(\"input\");\n\t\t\t\tinput.setAttribute(\"type\", \"hidden\");\n\t\t\t\tel.appendChild(input).setAttribute(\"name\", \"D\");\n\n\t\t\t\t// Support: IE8\n\t\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\t\tif (el.querySelectorAll(\"[name=d]\").length) {\n\t\t\t\t\trbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n\t\t\t\t}\n\n\t\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif (el.querySelectorAll(\":enabled\").length !== 2) {\n\t\t\t\t\trbuggyQSA.push(\":enabled\", \":disabled\");\n\t\t\t\t}\n\n\t\t\t\t// Support: IE9-11+\n\t\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\t\tdocElem.appendChild(el).disabled = true;\n\t\t\t\tif (el.querySelectorAll(\":disabled\").length !== 2) {\n\t\t\t\t\trbuggyQSA.push(\":enabled\", \":disabled\");\n\t\t\t\t}\n\n\t\t\t\t// Support: Opera 10 - 11 only\n\t\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\t\trbuggyQSA.push(\",.*:\");\n\t\t\t});\n\t\t}\n\n\t\tif (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n\n\t\t\tassert(function (el) {\n\n\t\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t\t// on a disconnected node (IE 9)\n\t\t\t\tsupport.disconnectedMatch = matches.call(el, \"*\");\n\n\t\t\t\t// This should fail with an exception\n\t\t\t\t// Gecko does not error, returns false instead\n\t\t\t\tmatches.call(el, \"[s!='']:x\");\n\t\t\t\trbuggyMatches.push(\"!=\", pseudos);\n\t\t\t});\n\t\t}\n\n\t\trbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n\t\trbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n\n\t\t/* Contains\n  ---------------------------------------------------------------------- */\n\t\thasCompare = rnative.test(docElem.compareDocumentPosition);\n\n\t\t// Element contains another\n\t\t// Purposefully self-exclusive\n\t\t// As in, an element does not contain itself\n\t\tcontains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t    bup = b && b.parentNode;\n\t\t\treturn a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n\t\t} : function (a, b) {\n\t\t\tif (b) {\n\t\t\t\twhile (b = b.parentNode) {\n\t\t\t\t\tif (b === a) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\t/* Sorting\n  ---------------------------------------------------------------------- */\n\n\t\t// Document order sorting\n\t\tsortOrder = hasCompare ? function (a, b) {\n\n\t\t\t// Flag for duplicate removal\n\t\t\tif (a === b) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\t\tif (compare) {\n\t\t\t\treturn compare;\n\t\t\t}\n\n\t\t\t// Calculate position if both inputs belong to the same document\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tcompare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t\t// Disconnected nodes\n\t\t\tif (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n\n\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\tif (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\tif (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t// Maintain original order\n\t\t\t\treturn sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n\t\t\t}\n\n\t\t\treturn compare & 4 ? -1 : 1;\n\t\t} : function (a, b) {\n\n\t\t\t// Exit early if the nodes are identical\n\t\t\tif (a === b) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar cur,\n\t\t\t    i = 0,\n\t\t\t    aup = a.parentNode,\n\t\t\t    bup = b.parentNode,\n\t\t\t    ap = [a],\n\t\t\t    bp = [b];\n\n\t\t\t// Parentless nodes are either documents or disconnected\n\t\t\tif (!aup || !bup) {\n\n\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t/* eslint-disable eqeqeq */\n\t\t\t\treturn a == document ? -1 : b == document ? 1 :\n\t\t\t\t/* eslint-enable eqeqeq */\n\t\t\t\taup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n\n\t\t\t\t// If the nodes are siblings, we can do a quick check\n\t\t\t} else if (aup === bup) {\n\t\t\t\treturn siblingCheck(a, b);\n\t\t\t}\n\n\t\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\t\tcur = a;\n\t\t\twhile (cur = cur.parentNode) {\n\t\t\t\tap.unshift(cur);\n\t\t\t}\n\t\t\tcur = b;\n\t\t\twhile (cur = cur.parentNode) {\n\t\t\t\tbp.unshift(cur);\n\t\t\t}\n\n\t\t\t// Walk down the tree looking for a discrepancy\n\t\t\twhile (ap[i] === bp[i]) {\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\treturn i ?\n\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck(ap[i], bp[i]) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t/* eslint-disable eqeqeq */\n\t\t\tap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 :\n\t\t\t/* eslint-enable eqeqeq */\n\t\t\t0;\n\t\t};\n\n\t\treturn document;\n\t};\n\n\tSizzle.matches = function (expr, elements) {\n\t\treturn Sizzle(expr, null, null, elements);\n\t};\n\n\tSizzle.matchesSelector = function (elem, expr) {\n\t\tsetDocument(elem);\n\n\t\tif (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + \" \"] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n\n\t\t\ttry {\n\t\t\t\tvar ret = matches.call(elem, expr);\n\n\t\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\t\tif (ret || support.disconnectedMatch ||\n\n\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t// fragment in IE 9\n\t\t\t\telem.document && elem.document.nodeType !== 11) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tnonnativeSelectorCache(expr, true);\n\t\t\t}\n\t\t}\n\n\t\treturn Sizzle(expr, document, null, [elem]).length > 0;\n\t};\n\n\tSizzle.contains = function (context, elem) {\n\n\t\t// Set document vars if needed\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tif ((context.ownerDocument || context) != document) {\n\t\t\tsetDocument(context);\n\t\t}\n\t\treturn contains(context, elem);\n\t};\n\n\tSizzle.attr = function (elem, name) {\n\n\t\t// Set document vars if needed\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tif ((elem.ownerDocument || elem) != document) {\n\t\t\tsetDocument(elem);\n\t\t}\n\n\t\tvar fn = Expr.attrHandle[name.toLowerCase()],\n\n\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n\n\t\treturn val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n\t};\n\n\tSizzle.escape = function (sel) {\n\t\treturn (sel + \"\").replace(rcssescape, fcssescape);\n\t};\n\n\tSizzle.error = function (msg) {\n\t\tthrow new Error(\"Syntax error, unrecognized expression: \" + msg);\n\t};\n\n\t/**\n  * Document sorting and removing duplicates\n  * @param {ArrayLike} results\n  */\n\tSizzle.uniqueSort = function (results) {\n\t\tvar elem,\n\t\t    duplicates = [],\n\t\t    j = 0,\n\t\t    i = 0;\n\n\t\t// Unless we *know* we can detect duplicates, assume their presence\n\t\thasDuplicate = !support.detectDuplicates;\n\t\tsortInput = !support.sortStable && results.slice(0);\n\t\tresults.sort(sortOrder);\n\n\t\tif (hasDuplicate) {\n\t\t\twhile (elem = results[i++]) {\n\t\t\t\tif (elem === results[i]) {\n\t\t\t\t\tj = duplicates.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (j--) {\n\t\t\t\tresults.splice(duplicates[j], 1);\n\t\t\t}\n\t\t}\n\n\t\t// Clear input after sorting to release objects\n\t\t// See https://github.com/jquery/sizzle/pull/225\n\t\tsortInput = null;\n\n\t\treturn results;\n\t};\n\n\t/**\n  * Utility function for retrieving the text value of an array of DOM nodes\n  * @param {Array|Element} elem\n  */\n\tgetText = Sizzle.getText = function (elem) {\n\t\tvar node,\n\t\t    ret = \"\",\n\t\t    i = 0,\n\t\t    nodeType = elem.nodeType;\n\n\t\tif (!nodeType) {\n\n\t\t\t// If no nodeType, this is expected to be an array\n\t\t\twhile (node = elem[i++]) {\n\n\t\t\t\t// Do not traverse comment nodes\n\t\t\t\tret += getText(node);\n\t\t\t}\n\t\t} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n\n\t\t\t// Use textContent for elements\n\t\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\t\tif (typeof elem.textContent === \"string\") {\n\t\t\t\treturn elem.textContent;\n\t\t\t} else {\n\n\t\t\t\t// Traverse its children\n\t\t\t\tfor (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n\t\t\t\t\tret += getText(elem);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (nodeType === 3 || nodeType === 4) {\n\t\t\treturn elem.nodeValue;\n\t\t}\n\n\t\t// Do not include comment or processing instruction nodes\n\n\t\treturn ret;\n\t};\n\n\tExpr = Sizzle.selectors = {\n\n\t\t// Can be adjusted by the user\n\t\tcacheLength: 50,\n\n\t\tcreatePseudo: markFunction,\n\n\t\tmatch: matchExpr,\n\n\t\tattrHandle: {},\n\n\t\tfind: {},\n\n\t\trelative: {\n\t\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\t\" \": { dir: \"parentNode\" },\n\t\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\t\"~\": { dir: \"previousSibling\" }\n\t\t},\n\n\t\tpreFilter: {\n\t\t\t\"ATTR\": function ATTR(match) {\n\t\t\t\tmatch[1] = match[1].replace(runescape, funescape);\n\n\t\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\t\tmatch[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n\t\t\t\tif (match[2] === \"~=\") {\n\t\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t\t}\n\n\t\t\t\treturn match.slice(0, 4);\n\t\t\t},\n\n\t\t\t\"CHILD\": function CHILD(match) {\n\n\t\t\t\t/* matches from matchExpr[\"CHILD\"]\n    \t1 type (only|nth|...)\n    \t2 what (child|of-type)\n    \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n    \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n    \t5 sign of xn-component\n    \t6 x of xn-component\n    \t7 sign of y-component\n    \t8 y of y-component\n    */\n\t\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\t\tif (match[1].slice(0, 3) === \"nth\") {\n\n\t\t\t\t\t// nth-* requires argument\n\t\t\t\t\tif (!match[3]) {\n\t\t\t\t\t\tSizzle.error(match[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\t\tmatch[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n\t\t\t\t\tmatch[5] = +(match[7] + match[8] || match[3] === \"odd\");\n\n\t\t\t\t\t// other types prohibit arguments\n\t\t\t\t} else if (match[3]) {\n\t\t\t\t\tSizzle.error(match[0]);\n\t\t\t\t}\n\n\t\t\t\treturn match;\n\t\t\t},\n\n\t\t\t\"PSEUDO\": function PSEUDO(match) {\n\t\t\t\tvar excess,\n\t\t\t\t    unquoted = !match[6] && match[2];\n\n\t\t\t\tif (matchExpr[\"CHILD\"].test(match[0])) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// Accept quoted arguments as-is\n\t\t\t\tif (match[3]) {\n\t\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t\t} else if (unquoted && rpseudo.test(unquoted) && (\n\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\texcess = tokenize(unquoted, true)) && (\n\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\texcess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n\n\t\t\t\t\t// excess is a negative index\n\t\t\t\t\tmatch[0] = match[0].slice(0, excess);\n\t\t\t\t\tmatch[2] = unquoted.slice(0, excess);\n\t\t\t\t}\n\n\t\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\t\treturn match.slice(0, 3);\n\t\t\t}\n\t\t},\n\n\t\tfilter: {\n\n\t\t\t\"TAG\": function TAG(nodeNameSelector) {\n\t\t\t\tvar nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n\t\t\t\treturn nodeNameSelector === \"*\" ? function () {\n\t\t\t\t\treturn true;\n\t\t\t\t} : function (elem) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t\"CLASS\": function CLASS(className) {\n\t\t\t\tvar pattern = classCache[className + \" \"];\n\n\t\t\t\treturn pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n\t\t\t\t\treturn pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t\"ATTR\": function ATTR(name, operator, check) {\n\t\t\t\treturn function (elem) {\n\t\t\t\t\tvar result = Sizzle.attr(elem, name);\n\n\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t\t}\n\t\t\t\t\tif (!operator) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult += \"\";\n\n\t\t\t\t\t/* eslint-disable max-len */\n\n\t\t\t\t\treturn operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n\t\t\t\t\t/* eslint-enable max-len */\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t\"CHILD\": function CHILD(type, what, _argument, first, last) {\n\t\t\t\tvar simple = type.slice(0, 3) !== \"nth\",\n\t\t\t\t    forward = type.slice(-4) !== \"last\",\n\t\t\t\t    ofType = what === \"of-type\";\n\n\t\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction (elem) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} : function (elem, _context, xml) {\n\t\t\t\t\tvar cache,\n\t\t\t\t\t    uniqueCache,\n\t\t\t\t\t    outerCache,\n\t\t\t\t\t    node,\n\t\t\t\t\t    nodeIndex,\n\t\t\t\t\t    start,\n\t\t\t\t\t    dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t    parent = elem.parentNode,\n\t\t\t\t\t    name = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t    useCache = !xml && !ofType,\n\t\t\t\t\t    diff = false;\n\n\t\t\t\t\tif (parent) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif (simple) {\n\t\t\t\t\t\t\twhile (dir) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile (node = node[dir]) {\n\t\t\t\t\t\t\t\t\tif (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [forward ? parent.firstChild : parent.lastChild];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif (forward && useCache) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[expando] || (node[expando] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[type] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[nodeIndex];\n\n\t\t\t\t\t\t\twhile (node = ++nodeIndex && node && node[dir] || (\n\n\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\tdiff = nodeIndex = 0) || start.pop()) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif (node.nodeType === 1 && ++diff && node === elem) {\n\t\t\t\t\t\t\t\t\tuniqueCache[type] = [dirruns, nodeIndex, diff];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif (useCache) {\n\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[expando] || (node[expando] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[type] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif (diff === false) {\n\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n\n\t\t\t\t\t\t\t\t\tif ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif (useCache) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[expando] || (node[expando] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[type] = [dirruns, diff];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (node === elem) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || diff % first === 0 && diff / first >= 0;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t\"PSEUDO\": function PSEUDO(pseudo, argument) {\n\n\t\t\t\t// pseudo-class names are case-insensitive\n\t\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\t\tvar args,\n\t\t\t\t    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo);\n\n\t\t\t\t// The user may use createPseudo to indicate that\n\t\t\t\t// arguments are needed to create the filter function\n\t\t\t\t// just as Sizzle does\n\t\t\t\tif (fn[expando]) {\n\t\t\t\t\treturn fn(argument);\n\t\t\t\t}\n\n\t\t\t\t// But maintain support for old signatures\n\t\t\t\tif (fn.length > 1) {\n\t\t\t\t\targs = [pseudo, pseudo, \"\", argument];\n\t\t\t\t\treturn Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t    matched = fn(seed, argument),\n\t\t\t\t\t\t    i = matched.length;\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tidx = indexOf(seed, matched[i]);\n\t\t\t\t\t\t\tseed[idx] = !(matches[idx] = matched[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}) : function (elem) {\n\t\t\t\t\t\treturn fn(elem, 0, args);\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn fn;\n\t\t\t}\n\t\t},\n\n\t\tpseudos: {\n\n\t\t\t// Potentially complex pseudos\n\t\t\t\"not\": markFunction(function (selector) {\n\n\t\t\t\t// Trim the selector passed to compile\n\t\t\t\t// to avoid treating leading and trailing\n\t\t\t\t// spaces as combinators\n\t\t\t\tvar input = [],\n\t\t\t\t    results = [],\n\t\t\t\t    matcher = compile(selector.replace(rtrim, \"$1\"));\n\n\t\t\t\treturn matcher[expando] ? markFunction(function (seed, matches, _context, xml) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t    unmatched = matcher(seed, null, xml, []),\n\t\t\t\t\t    i = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (elem = unmatched[i]) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) : function (elem, _context, xml) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher(input, null, xml, results);\n\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t\t}),\n\n\t\t\t\"has\": markFunction(function (selector) {\n\t\t\t\treturn function (elem) {\n\t\t\t\t\treturn Sizzle(selector, elem).length > 0;\n\t\t\t\t};\n\t\t\t}),\n\n\t\t\t\"contains\": markFunction(function (text) {\n\t\t\t\ttext = text.replace(runescape, funescape);\n\t\t\t\treturn function (elem) {\n\t\t\t\t\treturn (elem.textContent || getText(elem)).indexOf(text) > -1;\n\t\t\t\t};\n\t\t\t}),\n\n\t\t\t// \"Whether an element is represented by a :lang() selector\n\t\t\t// is based solely on the element's language value\n\t\t\t// being equal to the identifier C,\n\t\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t\t// The identifier C does not have to be a valid language name.\"\n\t\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\t\"lang\": markFunction(function (lang) {\n\n\t\t\t\t// lang value must be a valid identifier\n\t\t\t\tif (!ridentifier.test(lang || \"\")) {\n\t\t\t\t\tSizzle.error(\"unsupported lang: \" + lang);\n\t\t\t\t}\n\t\t\t\tlang = lang.replace(runescape, funescape).toLowerCase();\n\t\t\t\treturn function (elem) {\n\t\t\t\t\tvar elemLang;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n\n\t\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while ((elem = elem.parentNode) && elem.nodeType === 1);\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t}),\n\n\t\t\t// Miscellaneous\n\t\t\t\"target\": function target(elem) {\n\t\t\t\tvar hash = window.location && window.location.hash;\n\t\t\t\treturn hash && hash.slice(1) === elem.id;\n\t\t\t},\n\n\t\t\t\"root\": function root(elem) {\n\t\t\t\treturn elem === docElem;\n\t\t\t},\n\n\t\t\t\"focus\": function focus(elem) {\n\t\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t\t},\n\n\t\t\t// Boolean properties\n\t\t\t\"enabled\": createDisabledPseudo(false),\n\t\t\t\"disabled\": createDisabledPseudo(true),\n\n\t\t\t\"checked\": function checked(elem) {\n\n\t\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\t\treturn nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n\t\t\t},\n\n\t\t\t\"selected\": function selected(elem) {\n\n\t\t\t\t// Accessing this property makes selected-by-default\n\t\t\t\t// options in Safari work properly\n\t\t\t\tif (elem.parentNode) {\n\t\t\t\t\t// eslint-disable-next-line no-unused-expressions\n\t\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t\t}\n\n\t\t\t\treturn elem.selected === true;\n\t\t\t},\n\n\t\t\t// Contents\n\t\t\t\"empty\": function empty(elem) {\n\n\t\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\t\tfor (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n\t\t\t\t\tif (elem.nodeType < 6) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t\"parent\": function parent(elem) {\n\t\t\t\treturn !Expr.pseudos[\"empty\"](elem);\n\t\t\t},\n\n\t\t\t// Element/input types\n\t\t\t\"header\": function header(elem) {\n\t\t\t\treturn rheader.test(elem.nodeName);\n\t\t\t},\n\n\t\t\t\"input\": function input(elem) {\n\t\t\t\treturn rinputs.test(elem.nodeName);\n\t\t\t},\n\n\t\t\t\"button\": function button(elem) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t\t},\n\n\t\t\t\"text\": function text(elem) {\n\t\t\t\tvar attr;\n\t\t\t\treturn elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && (\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t(attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n\t\t\t},\n\n\t\t\t// Position-in-collection\n\t\t\t\"first\": createPositionalPseudo(function () {\n\t\t\t\treturn [0];\n\t\t\t}),\n\n\t\t\t\"last\": createPositionalPseudo(function (_matchIndexes, length) {\n\t\t\t\treturn [length - 1];\n\t\t\t}),\n\n\t\t\t\"eq\": createPositionalPseudo(function (_matchIndexes, length, argument) {\n\t\t\t\treturn [argument < 0 ? argument + length : argument];\n\t\t\t}),\n\n\t\t\t\"even\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\n\t\t\t\"odd\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\tvar i = 1;\n\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\n\t\t\t\"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument > length ? length : argument;\n\t\t\t\tfor (; --i >= 0;) {\n\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\n\t\t\t\"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor (; ++i < length;) {\n\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t})\n\t\t}\n\t};\n\n\tExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n\t// Add button/input type pseudos\n\tfor (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {\n\t\tExpr.pseudos[i] = createInputPseudo(i);\n\t}\n\tfor (i in { submit: true, reset: true }) {\n\t\tExpr.pseudos[i] = createButtonPseudo(i);\n\t}\n\n\t// Easy API for creating new setFilters\n\tfunction setFilters() {}\n\tsetFilters.prototype = Expr.filters = Expr.pseudos;\n\tExpr.setFilters = new setFilters();\n\n\ttokenize = Sizzle.tokenize = function (selector, parseOnly) {\n\t\tvar matched,\n\t\t    match,\n\t\t    tokens,\n\t\t    type,\n\t\t    soFar,\n\t\t    groups,\n\t\t    preFilters,\n\t\t    cached = tokenCache[selector + \" \"];\n\n\t\tif (cached) {\n\t\t\treturn parseOnly ? 0 : cached.slice(0);\n\t\t}\n\n\t\tsoFar = selector;\n\t\tgroups = [];\n\t\tpreFilters = Expr.preFilter;\n\n\t\twhile (soFar) {\n\n\t\t\t// Comma and first run\n\t\t\tif (!matched || (match = rcomma.exec(soFar))) {\n\t\t\t\tif (match) {\n\n\t\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\t\tsoFar = soFar.slice(match[0].length) || soFar;\n\t\t\t\t}\n\t\t\t\tgroups.push(tokens = []);\n\t\t\t}\n\n\t\t\tmatched = false;\n\n\t\t\t// Combinators\n\t\t\tif (match = rcombinators.exec(soFar)) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\n\t\t\t\t\t// Cast descendant combinators to space\n\t\t\t\t\ttype: match[0].replace(rtrim, \" \")\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice(matched.length);\n\t\t\t}\n\n\t\t\t// Filters\n\t\t\tfor (type in Expr.filter) {\n\t\t\t\tif ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\ttokens.push({\n\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\tmatches: match\n\t\t\t\t\t});\n\t\t\t\t\tsoFar = soFar.slice(matched.length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!matched) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Return the length of the invalid excess\n\t\t// if we're just parsing\n\t\t// Otherwise, throw an error or return tokens\n\t\treturn parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :\n\n\t\t// Cache the tokens\n\t\ttokenCache(selector, groups).slice(0);\n\t};\n\n\tfunction toSelector(tokens) {\n\t\tvar i = 0,\n\t\t    len = tokens.length,\n\t\t    selector = \"\";\n\t\tfor (; i < len; i++) {\n\t\t\tselector += tokens[i].value;\n\t\t}\n\t\treturn selector;\n\t}\n\n\tfunction addCombinator(matcher, combinator, base) {\n\t\tvar dir = combinator.dir,\n\t\t    skip = combinator.next,\n\t\t    key = skip || dir,\n\t\t    checkNonElements = base && key === \"parentNode\",\n\t\t    doneName = done++;\n\n\t\treturn combinator.first ?\n\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction (elem, context, xml) {\n\t\t\twhile (elem = elem[dir]) {\n\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\treturn matcher(elem, context, xml);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction (elem, context, xml) {\n\t\t\tvar oldCache,\n\t\t\t    uniqueCache,\n\t\t\t    outerCache,\n\t\t\t    newCache = [dirruns, doneName];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif (xml) {\n\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\tif (matcher(elem, context, xml)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\touterCache = elem[expando] || (elem[expando] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n\t\t\t\t\t\tif (skip && skip === elem.nodeName.toLowerCase()) {\n\t\t\t\t\t\t\telem = elem[dir] || elem;\n\t\t\t\t\t\t} else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn newCache[2] = oldCache[2];\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[key] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif (newCache[2] = matcher(elem, context, xml)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t}\n\n\tfunction elementMatcher(matchers) {\n\t\treturn matchers.length > 1 ? function (elem, context, xml) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile (i--) {\n\t\t\t\tif (!matchers[i](elem, context, xml)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} : matchers[0];\n\t}\n\n\tfunction multipleContexts(selector, contexts, results) {\n\t\tvar i = 0,\n\t\t    len = contexts.length;\n\t\tfor (; i < len; i++) {\n\t\t\tSizzle(selector, contexts[i], results);\n\t\t}\n\t\treturn results;\n\t}\n\n\tfunction condense(unmatched, map, filter, context, xml) {\n\t\tvar elem,\n\t\t    newUnmatched = [],\n\t\t    i = 0,\n\t\t    len = unmatched.length,\n\t\t    mapped = map != null;\n\n\t\tfor (; i < len; i++) {\n\t\t\tif (elem = unmatched[i]) {\n\t\t\t\tif (!filter || filter(elem, context, xml)) {\n\t\t\t\t\tnewUnmatched.push(elem);\n\t\t\t\t\tif (mapped) {\n\t\t\t\t\t\tmap.push(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn newUnmatched;\n\t}\n\n\tfunction setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n\t\tif (postFilter && !postFilter[expando]) {\n\t\t\tpostFilter = setMatcher(postFilter);\n\t\t}\n\t\tif (postFinder && !postFinder[expando]) {\n\t\t\tpostFinder = setMatcher(postFinder, postSelector);\n\t\t}\n\t\treturn markFunction(function (seed, results, context, xml) {\n\t\t\tvar temp,\n\t\t\t    i,\n\t\t\t    elem,\n\t\t\t    preMap = [],\n\t\t\t    postMap = [],\n\t\t\t    preexisting = results.length,\n\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n\t\t\t    matcherOut = matcher ?\n\n\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\tpostFinder || (seed ? preFilter : preexisting || postFilter) ?\n\n\t\t\t// ...intermediate processing is necessary\n\t\t\t[] :\n\n\t\t\t// ...otherwise use results directly\n\t\t\tresults : matcherIn;\n\n\t\t\t// Find primary matches\n\t\t\tif (matcher) {\n\t\t\t\tmatcher(matcherIn, matcherOut, context, xml);\n\t\t\t}\n\n\t\t\t// Apply postFilter\n\t\t\tif (postFilter) {\n\t\t\t\ttemp = condense(matcherOut, postMap);\n\t\t\t\tpostFilter(temp, [], context, xml);\n\n\t\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\t\ti = temp.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (elem = temp[i]) {\n\t\t\t\t\t\tmatcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (seed) {\n\t\t\t\tif (postFinder || preFilter) {\n\t\t\t\t\tif (postFinder) {\n\n\t\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\t\ttemp = [];\n\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (elem = matcherOut[i]) {\n\n\t\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\t\ttemp.push(matcherIn[i] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpostFinder(null, matcherOut = [], temp, xml);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n\n\t\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add elements to results, through postFinder if defined\n\t\t\t} else {\n\t\t\t\tmatcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\t\t\t\tif (postFinder) {\n\t\t\t\t\tpostFinder(null, results, matcherOut, xml);\n\t\t\t\t} else {\n\t\t\t\t\tpush.apply(results, matcherOut);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction matcherFromTokens(tokens) {\n\t\tvar checkContext,\n\t\t    matcher,\n\t\t    j,\n\t\t    len = tokens.length,\n\t\t    leadingRelative = Expr.relative[tokens[0].type],\n\t\t    implicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\t    i = leadingRelative ? 1 : 0,\n\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator(function (elem) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true),\n\t\t    matchAnyContext = addCombinator(function (elem) {\n\t\t\treturn indexOf(checkContext, elem) > -1;\n\t\t}, implicitRelative, true),\n\t\t    matchers = [function (elem, context, xml) {\n\t\t\tvar ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));\n\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t}];\n\n\t\tfor (; i < len; i++) {\n\t\t\tif (matcher = Expr.relative[tokens[i].type]) {\n\t\t\t\tmatchers = [addCombinator(elementMatcher(matchers), matcher)];\n\t\t\t} else {\n\t\t\t\tmatcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);\n\n\t\t\t\t// Return special upon seeing a positional matcher\n\t\t\t\tif (matcher[expando]) {\n\n\t\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\t\tj = ++i;\n\t\t\t\t\tfor (; j < len; j++) {\n\t\t\t\t\t\tif (Expr.relative[tokens[j].type]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(\n\n\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\ttokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === \" \" ? \"*\" : \"\" })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n\t\t\t\t}\n\t\t\t\tmatchers.push(matcher);\n\t\t\t}\n\t\t}\n\n\t\treturn elementMatcher(matchers);\n\t}\n\n\tfunction matcherFromGroupMatchers(elementMatchers, setMatchers) {\n\t\tvar bySet = setMatchers.length > 0,\n\t\t    byElement = elementMatchers.length > 0,\n\t\t    superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n\t\t\tvar elem,\n\t\t\t    j,\n\t\t\t    matcher,\n\t\t\t    matchedCount = 0,\n\t\t\t    i = \"0\",\n\t\t\t    unmatched = seed && [],\n\t\t\t    setMatched = [],\n\t\t\t    contextBackup = outermostContext,\n\n\n\t\t\t// We must always have either seed elements or outermost context\n\t\t\telems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n\n\n\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\tdirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n\t\t\t    len = elems.length;\n\n\t\t\tif (outermost) {\n\n\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\toutermostContext = context == document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor (; i !== len && (elem = elems[i]) != null; i++) {\n\t\t\t\tif (byElement && elem) {\n\t\t\t\t\tj = 0;\n\n\t\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\t\tif (!context && elem.ownerDocument != document) {\n\t\t\t\t\t\tsetDocument(elem);\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile (matcher = elementMatchers[j++]) {\n\t\t\t\t\t\tif (matcher(elem, context || document, xml)) {\n\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (outermost) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif (bySet) {\n\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif (elem = !matcher && elem) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif (seed) {\n\t\t\t\t\t\tunmatched.push(elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif (bySet && i !== matchedCount) {\n\t\t\t\tj = 0;\n\t\t\t\twhile (matcher = setMatchers[j++]) {\n\t\t\t\t\tmatcher(unmatched, setMatched, context, xml);\n\t\t\t\t}\n\n\t\t\t\tif (seed) {\n\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif (matchedCount > 0) {\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (!(unmatched[i] || setMatched[i])) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call(results);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense(setMatched);\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply(results, setMatched);\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n\n\t\t\t\t\tSizzle.uniqueSort(results);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif (outermost) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\t\treturn bySet ? markFunction(superMatcher) : superMatcher;\n\t}\n\n\tcompile = Sizzle.compile = function (selector, match /* Internal Use Only */) {\n\t\tvar i,\n\t\t    setMatchers = [],\n\t\t    elementMatchers = [],\n\t\t    cached = compilerCache[selector + \" \"];\n\n\t\tif (!cached) {\n\n\t\t\t// Generate a function of recursive functions that can be used to check each element\n\t\t\tif (!match) {\n\t\t\t\tmatch = tokenize(selector);\n\t\t\t}\n\t\t\ti = match.length;\n\t\t\twhile (i--) {\n\t\t\t\tcached = matcherFromTokens(match[i]);\n\t\t\t\tif (cached[expando]) {\n\t\t\t\t\tsetMatchers.push(cached);\n\t\t\t\t} else {\n\t\t\t\t\telementMatchers.push(cached);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Cache the compiled function\n\t\t\tcached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\n\n\t\t\t// Save selector and tokenization\n\t\t\tcached.selector = selector;\n\t\t}\n\t\treturn cached;\n\t};\n\n\t/**\n  * A low-level selection function that works with Sizzle's compiled\n  *  selector functions\n  * @param {String|Function} selector A selector or a pre-compiled\n  *  selector function built with Sizzle.compile\n  * @param {Element} context\n  * @param {Array} [results]\n  * @param {Array} [seed] A set of elements to match against\n  */\n\tselect = Sizzle.select = function (selector, context, results, seed) {\n\t\tvar i,\n\t\t    tokens,\n\t\t    token,\n\t\t    type,\n\t\t    find,\n\t\t    compiled = typeof selector === \"function\" && selector,\n\t\t    match = !seed && tokenize(selector = compiled.selector || selector);\n\n\t\tresults = results || [];\n\n\t\t// Try to minimize operations if there is only one selector in the list and no seed\n\t\t// (the latter of which guarantees us context)\n\t\tif (match.length === 1) {\n\n\t\t\t// Reduce context if the leading compound selector is an ID\n\t\t\ttokens = match[0] = match[0].slice(0);\n\t\t\tif (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n\n\t\t\t\tcontext = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\t\t\t\tif (!context) {\n\t\t\t\t\treturn results;\n\n\t\t\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t\t} else if (compiled) {\n\t\t\t\t\tcontext = context.parentNode;\n\t\t\t\t}\n\n\t\t\t\tselector = selector.slice(tokens.shift().value.length);\n\t\t\t}\n\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\t\t\twhile (i--) {\n\t\t\t\ttoken = tokens[i];\n\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif (Expr.relative[type = token.type]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (find = Expr.find[type]) {\n\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice(i, 1);\n\t\t\t\t\t\tselector = seed.length && toSelector(tokens);\n\t\t\t\t\t\tif (!selector) {\n\t\t\t\t\t\t\tpush.apply(results, seed);\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Compile and execute a filtering function if one is not provided\n\t\t// Provide `match` to avoid retokenization if we modified the selector above\n\t\t(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n\t\treturn results;\n\t};\n\n\t// One-time assignments\n\n\t// Sort stability\n\tsupport.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando;\n\n\t// Support: Chrome 14-35+\n\t// Always assume duplicates if they aren't passed to the comparison function\n\tsupport.detectDuplicates = !!hasDuplicate;\n\n\t// Initialize against the default document\n\tsetDocument();\n\n\t// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n\t// Detached nodes confoundingly follow *each other*\n\tsupport.sortDetached = assert(function (el) {\n\n\t\t// Should return 1, but returns 4 (following)\n\t\treturn el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n\t});\n\n\t// Support: IE<8\n\t// Prevent attribute/property \"interpolation\"\n\t// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\tif (!assert(function (el) {\n\t\tel.innerHTML = \"<a href='#'></a>\";\n\t\treturn el.firstChild.getAttribute(\"href\") === \"#\";\n\t})) {\n\t\taddHandle(\"type|href|height|width\", function (elem, name, isXML) {\n\t\t\tif (!isXML) {\n\t\t\t\treturn elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Support: IE<9\n\t// Use defaultValue in place of getAttribute(\"value\")\n\tif (!support.attributes || !assert(function (el) {\n\t\tel.innerHTML = \"<input/>\";\n\t\tel.firstChild.setAttribute(\"value\", \"\");\n\t\treturn el.firstChild.getAttribute(\"value\") === \"\";\n\t})) {\n\t\taddHandle(\"value\", function (elem, _name, isXML) {\n\t\t\tif (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n\t\t\t\treturn elem.defaultValue;\n\t\t\t}\n\t\t});\n\t}\n\n\t// Support: IE<9\n\t// Use getAttributeNode to fetch booleans when getAttribute lies\n\tif (!assert(function (el) {\n\t\treturn el.getAttribute(\"disabled\") == null;\n\t})) {\n\t\taddHandle(booleans, function (elem, name, isXML) {\n\t\t\tvar val;\n\t\t\tif (!isXML) {\n\t\t\t\treturn elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n\t\t\t}\n\t\t});\n\t}\n\n\t// EXPOSE\n\tvar _sizzle = window.Sizzle;\n\n\tSizzle.noConflict = function () {\n\t\tif (window.Sizzle === Sizzle) {\n\t\t\twindow.Sizzle = _sizzle;\n\t\t}\n\n\t\treturn Sizzle;\n\t};\n\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t\t\treturn Sizzle;\n\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\t\t// Sizzle requires that there be a global window in Common-JS like environments\n\t} else if (typeof module !== \"undefined\" && module.exports) {\n\t\tmodule.exports = Sizzle;\n\t} else {\n\t\twindow.Sizzle = Sizzle;\n\t}\n\n\t// EXPOSE\n})(window);\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.common = exports.optimize = exports.initOptions = exports.match = exports.getMultiSelector = exports.getSingleSelector = exports.select = undefined;\n\nvar _select = __webpack_require__(6);\n\nObject.defineProperty(exports, 'select', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_select).default;\n  }\n});\nObject.defineProperty(exports, 'getSingleSelector', {\n  enumerable: true,\n  get: function get() {\n    return _select.getSingleSelector;\n  }\n});\nObject.defineProperty(exports, 'getMultiSelector', {\n  enumerable: true,\n  get: function get() {\n    return _select.getMultiSelector;\n  }\n});\n\nvar _match = __webpack_require__(1);\n\nObject.defineProperty(exports, 'match', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_match).default;\n  }\n});\nObject.defineProperty(exports, 'initOptions', {\n  enumerable: true,\n  get: function get() {\n    return _match.initOptions;\n  }\n});\n\nvar _optimize = __webpack_require__(5);\n\nObject.defineProperty(exports, 'optimize', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_optimize).default;\n  }\n});\n\nvar _common2 = __webpack_require__(4);\n\nvar _common = _interopRequireWildcard(_common2);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.common = _common;\n\n/***/ }\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// optimal-select.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 783d9c26cba2349ca337","/**\n * # Utilities\n *\n * Convenience helpers.\n */\n\n/**\n * Create an array with the DOM nodes of the list\n *\n * @param  {NodeList}             nodes - [description]\n * @return {Array.<HTMLElement>}        - [description]\n */\nexport const convertNodeList = (nodes) => {\n  const { length } = nodes\n  const arr = new Array(length)\n  for (var i = 0; i < length; i++) {\n    arr[i] = nodes[i]\n  }\n  return arr\n}\n\n/**\n * Escape special characters and line breaks as a simplified version of 'CSS.escape()'\n *\n * Description of valid characters: https://mathiasbynens.be/notes/css-escapes\n *\n * @param  {String?} value - [description]\n * @return {String}        - [description]\n */\nexport const escapeValue = (value) =>\n  value && value.replace(/['\"`\\\\/:?&!#$%^()[\\]{|}*+;,.<=>@~]/g, '\\\\$&')\n    .replace(/\\n/g, '\\u00a0')\n\n/**\n * Partition array into two groups determined by predicate\n */\nexport const partition = (array, predicate) =>\n  array.reduce(\n    ([inner, outer], item) => predicate(item) ? [inner.concat(item), outer] : [inner, outer.concat(item)],\n    [[], []]\n  )\n\n\n\n/**\n * Determine if string is valid CSS identifier\n * \n * In CSS, identifiers (including element names, classes, and IDs in selectors) can contain\n * only the characters [a-zA-Z0-9] and ISO 10646 characters U+00A0 and higher, plus the hyphen (-)\n * and the underscore (_); they cannot start with a digit, two hyphens, or a hyphen followed by\n * a digit.\n * \n * Identifiers can also contain escaped characters and any ISO 10646 character as a numeric\n * code (see next item). For instance, the identifier \"B&W?\" may be written as \"B\\&W\\?\" or \"B\\26 W\\3F\".\n * @param {String} value \n * @return {Boolean}\n */\nexport const isValidCSSIdentifier = (value) =>\n  !!value && !/(^\\d)|(^--)|(^-\\d)/.test(value) && !/([^\\\\]|^)['\"`/:?&!#$%^()[\\]{|}*+;,.<=>@~]/.test(value)\n\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/utilities.js","/**\n * # Match\n *\n * Retrieve selector for a node.\n */\n\nimport { createPattern, getToString } from './pattern'\nimport { getSelect } from './selector'\nimport { escapeValue } from './utilities'\n\n/**\n * @typedef {import('./select').Options} Options\n * @typedef {import('./pattern').Pattern} Pattern\n * @typedef {import('./pattern').ToStringApi} Pattern\n */\n\nexport const defaultIgnore = {\n  attribute(attributeName) {\n    return [\n      'style',\n      'data-reactid',\n      'data-react-checksum'\n    ].indexOf(attributeName) > -1\n  },\n  contains: () => true\n}\n\nexport const initOptions = (options = {}) => ({\n  ...options,\n  root: options.root || document,\n  skip: options.skip || null,\n  priority: options.priority || ['id', 'class', 'href', 'src'],\n  ignore: options.ignore || {}\n})\n\n/**\n * Get the path of the element\n *\n * @param  {HTMLElement} node      - [description]\n * @param  {Options}     [options] - [description]\n * @return {Array.<Pattern>}       - [description]\n */\nexport default function match(node, options = {}, nested = false) {\n  options = initOptions(options)\n  const { root, skip, ignore, format } = options\n\n  const path = []\n  let element = node\n  let length = path.length\n  const select = getSelect(options)\n  const toString = getToString(options)\n\n  const skipCompare = skip && (Array.isArray(skip) ? skip : [skip]).map((entry) => {\n    if (typeof entry !== 'function') {\n      return (element) => element === entry\n    }\n    return entry\n  })\n\n  const skipChecks = (element) => {\n    return skip && skipCompare.some((compare) => compare(element))\n  }\n\n  Object.keys(ignore).forEach((type) => {\n    var predicate = ignore[type]\n    if (typeof predicate === 'function') return\n    if (typeof predicate === 'number') {\n      predicate = predicate.toString()\n    }\n    if (typeof predicate === 'string') {\n      predicate = new RegExp(escapeValue(predicate).replace(/\\\\/g, '\\\\\\\\'))\n    }\n    if (typeof predicate === 'boolean') {\n      predicate = predicate ? /(?:)/ : /.^/\n    }\n    // check class-/attributename for regex\n    ignore[type] = (name, value) => predicate.test(value)\n  })\n\n  while (element !== root && element.nodeType !== 11) {\n    if (skipChecks(element) !== true) {\n      // ~ global\n      if (checkAttributes(element, path, options, select, toString, root)) break\n      if (checkTag(element, path, options, select, toString, root)) break\n\n      // ~ local\n      checkAttributes(element, path, options, select, toString)\n      if (path.length === length) {\n        checkTag(element, path, options, select, toString)\n      }\n\n      if (path.length === length && [1, 'xpath'].includes(format) && !nested && element === node) {\n        checkRecursiveDescendants(element, path, options, select, toString)\n      }\n\n      if (path.length === length && [1, 'xpath', 'jquery'].includes(format)) {\n        checkText(element, path, options, select, toString, format === 'jquery')\n      }\n\n      if (path.length === length) {\n        checkNthChild(element, path, options)\n      }\n    }\n\n    element = element.parentNode\n    length = path.length\n  }\n\n  if (element === root) {\n    const pattern = findPattern(element, options, select, toString)\n    path.unshift(pattern)\n  }\n\n  return path\n}\n\n/**\n * Extend path with attribute identifier\n *\n * @param  {HTMLElement}     element  - [description]\n * @param  {Array.<Pattern>} path     - [description]\n * @param  {Options}         options  - [description]\n * @param  {function}        select   - [description]\n * @param  {ToStringApi}     toString - [description]\n * @param  {HTMLElement}     parent   - [description]\n * @return {boolean}                  - [description]\n */\nconst checkAttributes = (element, path, { priority, ignore }, select, toString, parent = element.parentNode) => {\n  const pattern = findAttributesPattern(priority, element, ignore, select, toString, parent)\n  if (pattern) {\n    path.unshift(pattern)\n    return true\n  }\n  return false\n}\n\n/**\n * Calculates array of combinations of items in input array.\n * @param  {Array.<any>} values   - array of values\n * @param  {Object} options       - options: min - minimum subset size; max - maximum subset size\n * @return {Array.<Array.<any>>?}   array of subsets\n */\nexport const combinations = (values, options) => {\n  const { min, max } = options || {}\n  const result = [[]]\n\n  values.forEach(v => {\n    result.forEach(r => {\n      if (!max || r.length < max) {\n        result.push(r.concat(v))\n      }\n    })\n  })\n\n  result.shift()\n  return min ? result.filter(r => r.length >= min) : result\n}\n\n// limit subset size to increase performance\nconst maxSubsetSize = [\n  { items: 13, max: 1 },\n  { items: 10, max: 2 },\n  { items: 8, max: 3 },\n  { items: 5, max: 4 }\n]\n\n/**\n * Get class selector\n *\n * @param  {Array.<string>} classes - [description]\n * @param  {function}       select  - [description]\n * @param  {ToStringApi}    toString - [description]\n * @param  {HTMLElement}    parent  - [description]\n * @param  {Pattern}        base    - [description]\n * @return {Array.<string>?}        - [description]\n */\nconst getClassSelector = (classes = [], select, toString, parent, base) => {\n  const { max } =\n    maxSubsetSize.find(({ items }) => classes.length > items) || { max: classes.length }\n\n  let result = combinations(classes, { max })\n\n  for (let i = 0; i < result.length; i++) {\n    const pattern = toString.pattern({ ...base, classes: result[i] })\n    const matches = select(pattern, parent)\n    if (matches.length === 1) {\n      return result[i]\n    }\n  }\n\n  return null\n}\n\n/**\n * Lookup attribute identifier\n *\n * @param  {Array.<string>} priority  - [description]\n * @param  {HTMLElement}    element   - [description]\n * @param  {Object}         ignore    - [description]\n * @param  {function}       select    - [description]\n * @param  {ToStringApi}    toString  - [description]\n * @param  {ParentNode}     parent    - [description]\n * @return {Pattern?}                 - [description]\n */\nconst findAttributesPattern = (priority, element, ignore, select, toString, parent = element.parentNode) => {\n  const attributes = element.attributes\n  var attributeNames = Object.keys(attributes).map((val) => attributes[val].name)\n    .filter((a) => priority.indexOf(a) < 0)\n\n  var sortedKeys = [...priority, ...attributeNames]\n  var pattern = createPattern()\n  pattern.tag = element.tagName.toLowerCase()\n\n  var isOptimal = (pattern) => (select(toString.pattern(pattern), parent).length === 1)\n\n  for (var i = 0, l = sortedKeys.length; i < l; i++) {\n    const key = sortedKeys[i]\n    const attribute = attributes[key]\n    const attributeName = escapeValue(attribute && attribute.name)\n    const attributeValue = escapeValue(attribute && attribute.value)\n    const useNamedIgnore = attributeName !== 'class'\n\n    const currentIgnore = (useNamedIgnore && ignore[attributeName]) || ignore.attribute\n    const currentDefaultIgnore = (useNamedIgnore && defaultIgnore[attributeName]) || defaultIgnore.attribute\n    if (checkIgnore(currentIgnore, attributeName, attributeValue, currentDefaultIgnore)) {\n      continue\n    }\n\n    switch (attributeName) {\n      case 'class': {\n        let classNames = attributeValue.trim().split(/\\s+/g)\n        if (!classNames[0]) { // empty string\n          break\n        }\n        const classIgnore = ignore.class || defaultIgnore.class\n        if (classIgnore) {\n          classNames = classNames.filter(className => !classIgnore(className))\n        }\n        if (classNames.length > 0) {\n          const classes = getClassSelector(classNames, select, toString, parent, pattern)\n          if (classes) {\n            pattern.classes = classes\n            if (isOptimal(pattern)) {\n              return pattern\n            }\n          }\n        }\n      }\n        break\n\n      default:\n        pattern.attributes.push({ name: attributeName, value: attributeValue })\n        if (isOptimal(pattern)) {\n          return pattern\n        }\n    }\n  }\n\n  return null\n}\n\n\n/**\n * Extend path with tag identifier\n *\n * @param  {HTMLElement}     element - [description]\n * @param  {Options}         options  - [description]\n * @param  {Array.<Pattern>} path    - [description]\n * @param  {function}        select  - [description]\n * @param  {ToStringApi}     toString - [description]\n * @param  {HTMLElement}     parent  - [description]\n * @return {boolean}                 - [description]\n */\nconst checkTag = (element, path, { ignore }, select, toString, parent = element.parentNode) => {\n  const pattern = findTagPattern(element, ignore)\n  if (pattern) {\n    let matches = []\n    matches = select(toString.pattern(pattern), parent)\n    if (matches.length === 1) {\n      path.unshift(pattern)\n      if (pattern.tag === 'iframe') {\n        return false\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Lookup tag identifier\n *\n * @param  {HTMLElement} element - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Pattern?}            - [description]\n */\nconst findTagPattern = (element, ignore) => {\n  const tagName = element.tagName.toLowerCase()\n  if (checkIgnore(ignore.tag, null, tagName)) {\n    return null\n  }\n  const pattern = createPattern()\n  pattern.tag = tagName\n  return pattern\n}\n\n/**\n * Extend path with specific child identifier\n *\n * @param  {HTMLElement}     element - [description]\n * @param  {Options}         options - [description]\n * @param  {Array.<Pattern>} path    - [description]\n * @return {boolean}                 - [description]\n */\nconst checkNthChild = (element, path, { ignore }) => {\n  const parent = element.parentNode\n  const children = parent.children\n  for (var i = 0, l = children.length; i < l; i++) {\n    const child = children[i]\n    if (child === element) {\n      const childPattern = findTagPattern(child, ignore)\n      if (!childPattern) {\n        return console.warn(`\n          Element couldn't be matched through strict ignore pattern!\n        `, child, ignore, childPattern)\n      }\n      childPattern.relates = 'child'\n      childPattern.pseudo = [`nth-child(${i + 1})`]\n      path.unshift(childPattern)\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Extend path with contains\n *\n * @param  {HTMLElement}     element  - [description]\n * @param  {Array.<Pattern>} path     - [description]\n * @param  {Options}         options  - [description]\n * @param  {function}        select   - [description]\n * @param  {ToStringApi}     toString - [description]\n * @param  {boolean}         nested   - [description]\n * @return {boolean}                  - [description]\n */\nconst checkText = (element, path, { ignore }, select, toString, nested) => {\n  const pattern = findTagPattern(element, ignore)\n  if (!pattern) {\n    return false\n  }\n  const textContent = (nested ? element.textContent : (element.firstChild && element.firstChild.nodeValue) || '')\n  if (!textContent) {\n    return false\n  }\n\n  pattern.relates = 'child'\n  const parent = element.parentNode\n  const texts = textContent\n    .replace(/\\n+/g, '\\n')\n    .split('\\n')\n    .map(text => text.trim())\n    .filter(text => text.length > 0)\n\n  const contains = []\n\n  while (texts.length > 0) {\n    const text = texts.shift()\n    if (checkIgnore(ignore.contains, null, text, defaultIgnore.contains)) {\n      break\n    }\n    contains.push(`contains(\"${text}\")`)\n\n    const matches = select(toString.pattern({ ...pattern, pseudo: contains }), parent)\n    if (matches.length === 1) {\n      pattern.pseudo = contains\n      path.unshift(pattern)\n      return true\n    }\n    if (matches.length === 0) {\n      return false\n    }\n  }\n  return false\n}\n\n/**\n * Extend path with descendant tag\n *\n * @param  {HTMLElement}     element  - [description]\n * @param  {Array.<Pattern>} path     - [description]\n * @param  {Options}         options  - [description]\n * @param  {function}        select   - [description]\n * @param  {ToStringApi}     toString - [description]\n * @return {boolean}                  - [description]\n */\nconst checkRecursiveDescendants = (element, path, options, select, toString) => {\n  const pattern = findTagPattern(element, options.ignore)\n  if (!pattern) {\n    return false\n  }\n\n  const descendants = Array.from(element.querySelectorAll('*'))\n  while (descendants.length > 0) {\n    const descendantPath = match(descendants.shift(), { ...options, root: element }, true)\n    // avoid descendant selectors with nth-child\n    if (!descendantPath.some(pattern => pattern.pseudo.some(p => p.startsWith('nth-child')))) {\n      const parent = element.parentElement\n      const matches = select(toString.pattern({ ...pattern, descendants: [descendantPath] }), parent)\n      if (matches.length === 1) {\n        pattern.descendants = [descendantPath]\n        path.unshift(pattern)\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\n/**\n * Lookup identifier\n *\n * @param  {HTMLElement}    element  - [description]\n * @param  {Options}        options   - [description]\n * @param  {function}       select   - [description]\n * @param  {ToStringApi}    toString - [description]\n * @return {Pattern}                 - [description]\n */\nconst findPattern = (element, { priority, ignore }, select, toString) => {\n  var pattern = findAttributesPattern(priority, element, ignore, select, toString)\n  if (!pattern) {\n    pattern = findTagPattern(element, ignore)\n  }\n  return pattern\n}\n\n/**\n * Validate with custom and default functions\n *\n * @param  {Function} predicate        - [description]\n * @param  {string?}  name             - [description]\n * @param  {string}   value            - [description]\n * @param  {Function} defaultPredicate - [description]\n * @return {boolean}                   - [description]\n */\nexport const checkIgnore = (predicate, name, value, defaultPredicate) => {\n  if (!value) {\n    return true\n  }\n  const check = predicate || defaultPredicate\n  if (!check) {\n    return false\n  }\n  return check(name, value, defaultPredicate)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/match.js","import { isValidCSSIdentifier } from './utilities'\n/**\n * @typedef  {Object} Pattern\n * @property {('descendant' | 'child')}                  [relates]\n * @property {string}                                    [tag]\n * @property {Array.<{ name: string, value: string? }>}  attributes\n * @property {Array.<string>}                            classes\n * @property {Array.<string>}                            pseudo\n * @property {Array.<Array.<Pattern>>}                   descendants\n */\n\n/**\n * Creates a new pattern structure\n * \n * @param {Partial<Pattern>} pattern\n * @returns {Pattern}\n */\nexport const createPattern = (base = {}) =>\n  ({ attributes: [], classes: [], pseudo: [], descendants: [], ...base })\n\n/**\n * Convert attributes to CSS selector\n * \n * @param {Array.<{ name: string, value: string? }>} attributes \n * @returns {string}\n */\nexport const attributesToSelector = (attributes) =>\n  attributes.map(({ name, value }) => {\n    if (value === null) {\n      return `[${name}]`\n    }\n    if (name === 'id' && isValidCSSIdentifier(value)) {\n      return `#${value}`\n    }\n    return `[${name}=\"${value}\"]`\n  }).join('')\n\n/**\n * Convert classes to CSS selector\n * \n * @param {Array.<string>} classes \n * @returns {string}\n */\nexport const classesToSelector = (classes) =>\n  classes.map(c => isValidCSSIdentifier(c) ? `.${c}` : `[class~=\"${c}\"]`).join('')\n\n/**\n * Convert pseudo selectors to CSS selector\n * \n * @param {Array.<string>} pseudo \n * @returns {string}\n */\nexport const pseudoToSelector = (pseudo) => pseudo.length ? `:${pseudo.join(':')}` : ''\n\n/**\n * Convert pattern to CSS selector\n * \n * @param {Pattern} pattern \n * @returns {string}\n */\nexport const patternToSelector = (pattern) => {\n  const { relates, tag, attributes, classes, pseudo } = pattern\n  const value = `${\n    relates === 'child' ? '> ' : ''\n  }${\n    tag || ''\n  }${\n    attributesToSelector(attributes)\n  }${\n    classesToSelector(classes)\n  }${\n    pseudoToSelector(pseudo)\n  }`\n  return value\n}\n\n/**\n * Converts path to string\n *\n * @param {Array.<Pattern>} path \n * @returns {string}\n */\nexport const pathToSelector = (path) =>\n  path.map(patternToSelector).join(' ')\n\n\nconst convertEscaping = (value) =>\n  value && value.replace(/\\\\([`\\\\/:?&!#$%^()[\\]{|}*+;,.<=>@~])/g, '$1')\n    .replace(/\\\\(['\"])/g, '$1$1')\n    .replace(/\\\\A /g, '\\n')\n\n/**\n* Convert attributes to XPath string\n* \n* @param {Array.<{ name: string, value: string? }>} attributes \n* @returns {string}\n*/\nexport const attributesToXPath = (attributes) =>\n  attributes.map(({ name, value }) => {\n    if (value === null) {\n      return `[@${name}]`\n    }\n    return `[@${name}=\"${convertEscaping(value)}\"]`\n  }).join('')\n\n/**\n* Convert classes to XPath string\n* \n* @param {Array.<string>} classes \n* @returns {string}\n*/\nexport const classesToXPath = (classes) =>\n  classes.map(c => `[contains(concat(\" \",normalize-space(@class),\" \"),\" ${c} \")]`).join('')\n\n/**\n* Convert pseudo selectors to XPath string\n* \n* @param {Array.<string>} pseudo \n* @returns {string}\n*/\nexport const pseudoToXPath = (pseudo) =>\n  pseudo.map(p => {\n    const match = p.match(/^(nth-child|nth-of-type|contains)\\((.+)\\)$/)\n    if (!match) {\n      return ''\n    }\n\n    switch (match[1]) {\n      case 'nth-child':\n        return `[(count(preceding-sibling::*)+1) = ${match[2]}]`\n\n      case 'nth-of-type':\n        return `[${match[2]}]`\n\n      case 'contains':\n        return `[contains(text(),${match[2]})]`\n\n      default:\n        return ''\n    }\n  }).join('')\n\n/**\n* Convert pattern to XPath string\n* \n* @param {Pattern} pattern \n* @returns {string}\n*/\nexport const patternToXPath = (pattern) => {\n  const { relates, tag, attributes, classes, pseudo, descendants } = pattern\n  const value = `${\n    relates === 'child' ? '/' : '//'\n  }${\n    tag || '*'\n  }${\n    attributesToXPath(attributes)\n  }${\n    classesToXPath(classes)\n  }${\n    pseudoToXPath(pseudo)\n  }${\n    descendantsToXPath(descendants)\n  }`\n  return value\n}\n\n/**\n* Converts path to XPath string\n*\n* @param {Array.<Pattern>} path \n* @returns {string}\n*/\nexport const pathToXPath = (path) => `.${path.map(patternToXPath).join('')}`\n\n/**\n* Convert child selectors to XPath string\n* \n* @param {Array.<Array.<Pattern>>} children \n* @returns {string}\n*/\nexport const descendantsToXPath = (children) =>\n  children.length ? `[${children.map(pathToXPath).join('][')}]` : ''\n\n  \nconst toString = {\n  'css': {\n    attributes: attributesToSelector,\n    classes: classesToSelector,\n    pseudo: pseudoToSelector,\n    pattern: patternToSelector,\n    path: pathToSelector\n  },\n  'xpath': {\n    attributes: attributesToXPath,\n    classes: classesToXPath,\n    pseudo: pseudoToXPath,\n    pattern: patternToXPath,\n    path: pathToXPath\n  },\n  'jquery': {}\n}\n\ntoString.jquery = toString.css\ntoString[0] = toString.css\ntoString[1] = toString.xpath\n  \n/**\n * @typedef  {Object} ToStringApi\n * @property {(attributes: Array.<{ name: string, value: string? }>) => string} attributes\n * @property {(classes: Array.<string>) => string}  classes\n * @property {(pseudo: Array.<string>) => string}   pseudo\n * @property {(pattern: Pattern) => string}         pattern\n * @property {(path: Array.<Pattern>) => string}    path\n */\n\n/**\n * \n * @param {Options} options \n * @returns {ToStringApi}\n */\nexport const getToString = (options = {}) =>\n  toString[options.format || 'css']\n\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/pattern.js","// import Sizzle from 'sizzle'\nlet Sizzle\n\n/**\n * Select element using jQuery\n * @param  {string}         selector\n * @param  {HTMLElement}    parent\n * @return Array.<HTMLElement>\n */\nconst selectJQuery = (selector, parent = null) => {\n  if (!Sizzle) {\n    Sizzle = require('sizzle')\n  }\n  return Sizzle(selector, parent || document)\n}\n  \n/**\n * Select element using XPath\n * @param  {string}         selector\n * @param  {HTMLElement}    parent\n * @return Array.<HTMLElement>\n */\nconst selectXPath = (selector, parent = null) => {\n  parent = (parent || document)\n  var doc = parent\n  while (doc.parentNode) {\n    doc = doc.parentNode\n  }\n  if (doc !== parent && !selector.startsWith('.')) {\n    selector = `.${selector}`\n  }\n  var iterator = doc.evaluate(selector, parent, null, 0)\n  var elements = []\n  var element\n  while ((element = iterator.iterateNext())) {\n    elements.push(element)\n  }\n  return elements\n}\n  \n/**\n * Select element using CSS\n * @param  {string}         selector\n * @param  {HTMLElement}    parent\n * @return Array.<HTMLElement>\n */\nconst selectCSS = (selector, parent = null) =>\n  (parent || document).querySelectorAll(selector)\n\nconst select = {\n  'css': selectCSS,\n  'xpath': selectXPath,\n  'jquery': selectJQuery\n}\n\nselect[0] = select.css\nselect[1] = select.xpath\n\n/**\n* \n* @param {Options} options \n* @returns {(selector: string, parent: HTMLElement) => Array.<HTMLElement>}\n*/\nexport const getSelect = (options = {}) =>\n  (selector, parent) => {\n    try {\n      return select[options.format || 'css'](selector, parent || options.root)\n    } catch (err) {\n      return []\n    }\n  }\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/selector.js","/**\n * # Common\n *\n * Process collections for similarities.\n */\n\n/**\n * @typedef {import('./select').Options} Options\n */\n\n/**\n * Find the last common ancestor of elements\n *\n * @param  {Array.<HTMLElement>} elements  - [description]\n * @param  {Options}              options  - [description]\n * @return {HTMLElement}                   - [description]\n */\nimport { defaultIgnore, checkIgnore } from './match'\nimport { escapeValue } from './utilities'\n\nexport const getCommonAncestor = (elements, options = {}) => {\n\n  const {\n    root = document\n  } = options\n\n  const ancestors = []\n\n  elements.forEach((element, index) => {\n    const parents = []\n    while (element !== root) {\n      element = element.parentNode\n      parents.unshift(element)\n    }\n    ancestors[index] = parents\n  })\n\n  ancestors.sort((curr, next) => curr.length - next.length)\n\n  const shallowAncestor = ancestors.shift()\n\n  var ancestor = null\n\n  for (var i = 0, l = shallowAncestor.length; i < l; i++) {\n    const parent = shallowAncestor[i]\n    const missing = ancestors.some((otherParents) => {\n      return !otherParents.some((otherParent) => otherParent === parent)\n    })\n\n    if (missing) {\n      // TODO: find similar sub-parents, not the top root, e.g. sharing a class selector\n      break\n    }\n\n    ancestor = parent\n  }\n\n  return ancestor\n}\n\n/**\n * Get a set of common properties of elements\n *\n * @param  {Array.<HTMLElement>} elements - [description]\n * @return {Object}                       - [description]\n */\nexport const getCommonProperties = (elements, options = {}) => {\n  const { ignore = {} } = options\n\n  const commonProperties = {\n    classes: [],\n    attributes: {},\n    tag: null\n  }\n\n  elements.forEach((element) => {\n\n    var {\n      classes: commonClasses,\n      attributes: commonAttributes,\n      tag: commonTag\n    } = commonProperties\n\n    // ~ classes\n    if (commonClasses !== undefined) {\n      var classes = element.getAttribute('class')\n      if (classes) {\n        classes = classes.trim().split(' ').filter(cls => !ignore.class || !ignore.class(cls))\n        if (!commonClasses.length) {\n          commonProperties.classes = classes\n        } else {\n          commonClasses = commonClasses.filter((entry) => classes.some((name) => name === entry))\n          if (commonClasses.length) {\n            commonProperties.classes = commonClasses\n          } else {\n            delete commonProperties.classes\n          }\n        }\n      } else {\n        delete commonProperties.classes\n      }\n    }\n\n    // ~ attributes\n    if (commonAttributes !== undefined) {\n      const elementAttributes = element.attributes\n      const attributes = Object.keys(elementAttributes).reduce((attributes, key) => {\n        const attribute = elementAttributes[key]\n        const attributeName = escapeValue(attribute && attribute.name)\n        const attributeValue = escapeValue(attribute && attribute.value)\n        const useNamedIgnore = attributeName !== 'class'\n        const currentIgnore = (useNamedIgnore && ignore[attributeName]) || ignore.attribute\n        const currentDefaultIgnore = (useNamedIgnore && defaultIgnore[attributeName]) || defaultIgnore.attribute\n        if (attribute && attributeName !== 'class' && !checkIgnore(currentIgnore, attributeName, attributeValue, currentDefaultIgnore)) {\n          attributes[attributeName] = attribute.value\n        }\n        return attributes\n      }, {})\n\n      const attributesNames = Object.keys(attributes)\n      const commonAttributesNames = Object.keys(commonAttributes)\n\n      if (attributesNames.length) {\n        if (!commonAttributesNames.length) {\n          commonProperties.attributes = attributes\n        } else {\n          commonAttributes = commonAttributesNames.reduce((nextCommonAttributes, name) => {\n            const value = commonAttributes[name]\n            if (value === attributes[name]) {\n              nextCommonAttributes[name] = value\n            }\n            return nextCommonAttributes\n          }, {})\n          if (Object.keys(commonAttributes).length) {\n            commonProperties.attributes = commonAttributes\n          } else {\n            delete commonProperties.attributes\n          }\n        }\n      } else {\n        delete commonProperties.attributes\n      }\n    }\n\n    // ~ tag\n    if (commonTag !== undefined) {\n      const tag = element.tagName.toLowerCase()\n      if (!commonTag) {\n        commonProperties.tag = tag\n      } else if (tag !== commonTag) {\n        delete commonProperties.tag\n      }\n    }\n  })\n\n  return commonProperties\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common.js","/**\n * # Optimize\n *\n * 1.) Improve efficiency through shorter selectors by removing redundancy\n * 2.) Improve robustness through selector transformation\n */\n\nimport { getSelect } from './selector'\nimport { createPattern, getToString } from './pattern'\nimport { convertNodeList, partition } from './utilities'\n\n/**\n * @typedef {import('./select').Options} Options\n * @typedef {import('./pattern').Pattern} Pattern\n * @typedef {import('./pattern').ToStringApi} Pattern\n */\n\n/**\n * Apply different optimization techniques\n *\n * @param  {Array.<Pattern>}                 path   - [description]\n * @param  {HTMLElement|Array.<HTMLElement>} element    - [description]\n * @param  {Options}                         [options]  - [description]\n * @return {Array.<Pattern>}                            - [description]\n */\nexport default function optimize (path, elements, options = {}) {\n  if (path.length === 0) {\n    return []\n  }\n\n  if (path[0].relates === 'child') {\n    path[0].relates = undefined\n  }\n\n  // convert single entry and NodeList\n  if (!Array.isArray(elements)) {\n    elements = !elements.length ? [elements] : convertNodeList(elements)\n  }\n\n  if (!elements.length || elements.some((element) => element.nodeType !== 1)) {\n    throw new Error('Invalid input - to compare HTMLElements its necessary to provide a reference of the selected node(s)! (missing \"elements\")')\n  }\n\n  const select = getSelect(options)\n  const toString = getToString(options)\n\n  if (path.length === 1) {\n    return [optimizePart([], path[0], [], elements, select, toString)]\n  }\n\n  var endOptimized = false\n  if (path[path.length-1].relates === 'child') {\n    path[path.length-1] = optimizePart(path.slice(0, -1), path[path.length-1], [], elements, select, toString)\n    endOptimized = true\n  }\n\n  path = [...path]\n  const shortened = [path.pop()]\n  while (path.length > 1) {\n    const current = path.pop()\n    const matches = select(toString.path([...path, ...shortened]))\n    const hasSameResult = matches.length === elements.length && elements.every((element, i) => element === matches[i])\n    if (!hasSameResult) {\n      shortened.unshift(optimizePart(path, current, shortened, elements, select, toString))\n    }\n  }\n  shortened.unshift(path[0])\n  path = shortened\n\n  // optimize start + end\n  path[0] = optimizePart([], path[0], path.slice(1), elements, select, toString)\n  if (!endOptimized) {\n    path[path.length-1] = optimizePart(path.slice(0, -1), path[path.length-1], [], elements, select, toString)\n  }\n\n  return path\n}\n\n/**\n * Optimize :contains\n *\n * @param  {Array.<Pattern>}     pre      - [description]\n * @param  {Pattern}             current  - [description]\n * @param  {Array.<Pattern>}     post     - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @param  {ToStringApi}         toString - [description]\n * @return {Pattern}                      - [description]\n */\nconst optimizeText = (pre, current, post, elements, select, toString) => {\n  const [contains, other] = partition(current.pseudo, (item) => item.startsWith('contains'))\n\n  if (contains.length > 0 && post.length) {\n    const base = { ...current, pseudo: [...other, ...contains] }\n    while (base.pseudo.length > other.length) {\n      const optimized = base.pseudo.slice(0, -1)\n      if (!compareResults(select(toString.path([...pre, { ...base, pseudo: optimized }, ...post])), elements)) {\n        break\n      }\n      base.pseudo = optimized\n    }\n    return base\n  }\n  return current\n}\n\n/**\n * Optimize attributes\n *\n * @param  {Array.<Pattern>}     pre      - [description]\n * @param  {Pattern}             current  - [description]\n * @param  {Array.<Pattern>}     post     - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @param  {ToStringApi}         toString - [description]\n * @return {Pattern}                      - [description]\n */\nconst optimizeAttributes = (pre, current, post, elements, select, toString) => {\n  // reduce attributes: first try without value, then removing completely\n  if (current.attributes.length > 0) {\n    let attributes = [...current.attributes]\n\n    const simplify = (original, getSimplified) => {\n      let i = original.length - 1\n      while (i >= 0) {\n        let attributes = getSimplified(original, i)\n        if (!compareResults(\n          select(toString.path([...pre, { ...current, attributes }, ...post])),\n          elements\n        )) {\n          break\n        }\n        i--\n        original = attributes\n      }\n      return original\n    }\n\n    const simplified = simplify(attributes, (attributes, i) => {\n      const { name } = attributes[i]\n      if (name === 'id') {\n        return attributes\n      }\n      return [...attributes.slice(0, i), { name, value: null }, ...attributes.slice(i + 1)]\n    })\n    return { ...current, attributes: simplify(simplified, attributes => attributes.slice(0, -1)) }    \n  }\n  return current\n}\n\n/**\n * Optimize descendant\n *\n * @param  {Array.<Pattern>}     pre      - [description]\n * @param  {Pattern}             current  - [description]\n * @param  {Array.<Pattern>}     post     - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @param  {ToStringApi}         toString - [description]\n * @return {Pattern}                      - [description]\n */\nconst optimizeDescendant = (pre, current, post, elements, select, toString) => {\n  // robustness: descendant instead child (heuristic)\n  if (current.relates === 'child') {\n    const descendant = { ...current, relates: undefined }\n    let matches = select(toString.path([...pre, descendant, ...post]))\n    if (compareResults(matches, elements)) {\n      return descendant\n    }\n  }\n  return current\n}\n\n/**\n * Optimize recursive descendants\n * \n * @param  {Array.<Pattern>}     pre      - [description]\n * @param  {Pattern}             current  - [description]\n * @param  {Array.<Pattern>}     post     - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @param  {ToStringApi}         toString - [description]\n * @return {Pattern}                      - [description]\n */\nconst optimizeRecursiveDescendants = (pre, current, post, elements, select, toString) => {\n  if (current.descendants.length > 0 && post.length) {\n    const base = { ...current, descendants: [...current.descendants] }\n    while (base.descendants.length > 0) {\n      const optimized = base.descendants.slice(0, -1)\n      if (!compareResults(select(toString.path([...pre, { ...base, descendants: optimized }, ...post])), elements)) {\n        break\n      }\n      base.descendants = optimized\n    }\n    return base\n  }\n  return current\n}\n\n/**\n * Optimize nth of type\n *\n * @param  {Array.<Pattern>}     pre      - [description]\n * @param  {Pattern}             current  - [description]\n * @param  {Array.<Pattern>}     post     - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @param  {ToStringApi}         toString - [description]\n * @return {Pattern}                      - [description]\n */\nconst optimizeNthOfType = (pre, current, post, elements, select, toString) => {\n  const i = current.pseudo.findIndex(item => item.startsWith('nth-child'))\n  // robustness: 'nth-of-type' instead 'nth-child' (heuristic)\n  if (i >= 0) {\n    // TODO: consider complete coverage of 'nth-of-type' replacement\n    const type = current.pseudo[i].replace(/^nth-child/, 'nth-of-type')\n    const nthOfType = { ...current, pseudo: [...current.pseudo.slice(0, i), type, ...current.pseudo.slice(i + 1)] }\n    let pattern = toString.path([...pre, nthOfType, ...post])\n    let matches = select(pattern)\n    if (compareResults(matches, elements)) {\n      return nthOfType\n    }\n  }\n  return current\n}\n\n/**\n * Optimize classes\n *\n * @param  {Array.<Pattern>}     pre      - [description]\n * @param  {Pattern}             current  - [description]\n * @param  {Array.<Pattern>}     post     - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @param  {ToStringApi}         toString - [description]\n * @return {Pattern}                      - [description]\n */\nconst optimizeClasses = (pre, current, post, elements, select, toString) => {\n  // efficiency: combinations of classname (partial permutations)\n  if (current.classes.length > 1) {\n    let optimized = current.classes.slice().sort((curr, next) => curr.length - next.length)\n\n    while (optimized.length > 1) {\n      optimized.shift()\n      const pattern = toString.path([...pre, { ...current, classes: optimized }, ...post])\n      if (!compareResults(select(pattern), elements)) {\n        break\n      }\n      current.classes = optimized\n    }\n\n    optimized = current.classes\n\n    if (optimized.length > 2) {\n      const base = createPattern({ classes: optimized })\n      const references = select(toString.path([...pre, base]))\n      for (var i = 0; i < references.length; i++) {\n        const reference = references[i]\n        if (elements.some((element) => reference.contains(element))) {\n          // TODO:\n          // - check using attributes + regard excludes\n          const description = createPattern({ tag: reference.tagName })\n          var pattern = toString.path([...pre, description, ...post])\n          var matches = select(pattern)\n          if (compareResults(matches, elements)) {\n            current = description\n          }\n          break\n        }\n      }\n    }\n  }\n  return current\n}\n\nconst optimizers = [\n  optimizeText,\n  optimizeAttributes,\n  optimizeDescendant,\n  optimizeRecursiveDescendants,\n  optimizeNthOfType,\n  optimizeClasses,\n]\n\n/**\n * Improve a chunk of the selector\n *\n * @param  {Array.<Pattern>}     pre      - [description]\n * @param  {Pattern}             current  - [description]\n * @param  {Array.<Pattern>}     post     - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {function}            select   - [description]\n * @param  {ToStringApi}         toString - [description]\n * @return {Pattern}                      - [description]\n */\nconst optimizePart = (pre, current, post, elements, select, toString) =>\n  optimizers.reduce((acc, optimizer) => optimizer(pre, acc, post, elements, select, toString), current)\n\n/**\n * Evaluate matches with expected elements\n *\n * @param  {Array.<HTMLElement>} matches  - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @return {Boolean}                      - [description]\n */\nexport const compareResults = (matches, elements) => {\n  const { length } = matches\n  return length === elements.length && elements.every((element) => {\n    for (var i = 0; i < length; i++) {\n      if (matches[i] === element) {\n        return true\n      }\n    }\n    return false\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/optimize.js","/**\n * # Select\n *\n * Construct a unique CSS query selector to access the selected DOM element(s).\n * For longevity it applies different matching and optimization strategies.\n */\nimport match from './match'\nimport optimize from './optimize'\nimport { convertNodeList, escapeValue } from './utilities'\nimport { getCommonAncestor, getCommonProperties } from './common'\nimport { getSelect } from './selector'\nimport { createPattern, getToString } from './pattern'\n\n/**\n * @typedef  {Object} Options\n * @property {HTMLElement} [root]                     Optionally specify the root element\n * @property {function | Array.<HTMLElement>} [skip]  Specify elements to skip\n * @property {Array.<string>} [priority]              Order of attribute processing\n * @property {Object<string, function | number | string | boolean} [ignore] Define patterns which shouldn't be included\n * @property {('css'|'xpath'|'jquery')} [format]      Output format    \n */\n\n/**\n * @typedef {import('./pattern').Pattern} Pattern\n */\n\n/**\n * Get a selector for the provided element\n *\n * @param  {HTMLElement} element   - [description]\n * @param  {Options}     [options] - [description]\n * @return {Array.<Pattern>}       - [description]\n */\nexport const getSingleSelectorPath = (element, options = {}) => {\n\n  if (element.nodeType === 3) {\n    element = element.parentNode\n  }\n\n  if (element.nodeType !== 1) {\n    throw new Error(`Invalid input - only HTMLElements or representations of them are supported! (not \"${typeof element}\")`)\n  }\n\n  const path = match(element, options)\n  const optimizedPath = optimize(path, element, options)\n\n  // debug\n  // console.log(`\n  //   selector:  ${path}\n  //   optimized: ${optimizedPath}\n  // `)\n\n  return optimizedPath\n}\n\n/**\n * Get a selector to match multiple descendants from an ancestor\n *\n * @param  {Array.<HTMLElement>|NodeList} elements   - [description]\n * @param  {Options}                      [options]  - [description]\n * @return {Array.<Pattern>}                         - [description]\n */\nexport const getMultiSelectorPath = (elements, options = {}) => {\n\n  if (!Array.isArray(elements)) {\n    elements = convertNodeList(elements)\n  }\n\n  if (elements.some((element) => element.nodeType !== 1)) {\n    throw new Error('Invalid input - only an Array of HTMLElements or representations of them is supported!')\n  }\n\n  const select = getSelect(options)\n  const toString = getToString(options)\n\n  const ancestor = getCommonAncestor(elements, options)\n  const ancestorPath = match(ancestor, options)\n\n  // TODO: consider usage of multiple selectors + parent-child relation + check for part redundancy\n  const commonPath = getCommonPath(elements, options)\n  const descendantPattern = commonPath[0]\n\n  const selectorPath = optimize([...ancestorPath, descendantPattern], elements, options)\n  const selectorMatches = convertNodeList(select(toString.path(selectorPath)))\n\n  if (!elements.every((element) => selectorMatches.some((entry) => entry === element))) {\n    // TODO: cluster matches to split into similar groups for sub selections\n    console.warn(`\n      The selected elements can't be efficiently mapped.\n      Its probably best to use multiple single selectors instead!\n    `)\n    return elements\n  }\n\n  return selectorPath\n}\n\n/**\n * Get selectors to describe a set of elements\n *\n * @param  {Array.<HTMLElement>} elements  - [description]\n * @return {Array.<Pattern>}               - [description]\n */\nconst getCommonPath = (elements, options) => {\n  const { classes, attributes, tag } = getCommonProperties(elements, options)\n\n\n  return [\n    createPattern({\n      tag,\n      classes: classes || [],\n      attributes: attributes ? Object.keys(attributes).map((name) => ({\n        name: escapeValue(name),\n        value: escapeValue(attributes[name])\n      })) : []\n    })\n  ]\n}\n\n/**\n * Choose action depending on the input (multiple/single)\n *\n * NOTE: extended detection is used for special cases like the <select> element with <options>\n *\n * @param  {HTMLElement|NodeList|Array.<HTMLElement>} input     - [description]\n * @param  {Options}                                  [options] - [description]\n * @return {string}                                             - [description]\n */\nexport default function getQuerySelector(input, options = {}) {\n  const path = (input.length && !input.name)\n    ? getMultiSelectorPath(input, options)\n    : getSingleSelectorPath(input, options)\n\n  if (Array.isArray(path) && path.length > 0 && path[0] instanceof HTMLElement) {\n    return path.map(entry => getQuerySelector(entry, options)).join(',')\n  }\n  return getToString(options).path(path)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/select.js","/*!\n * Sizzle CSS Selector Engine v2.3.6\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://js.foundation/\n *\n * Date: 2021-02-16\n */\n( function( window ) {\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tnonnativeSelectorCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ( {} ).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpushNative = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[ i ] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|\" +\n\t\t\"ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n\tidentifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace +\n\t\t\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\n\t\t// \"Attribute values must be CSS identifiers [capture 5]\n\t\t// or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" +\n\t\twhitespace + \"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" +\n\t\twhitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace +\n\t\t\"*\" ),\n\trdescend = new RegExp( whitespace + \"|>\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" +\n\t\t\twhitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" +\n\t\t\twhitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace +\n\t\t\t\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace +\n\t\t\t\"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trhtml = /HTML$/i,\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\" ),\n\tfunescape = function( escape, nonHex ) {\n\t\tvar high = \"0x\" + escape.slice( 1 ) - 0x10000;\n\n\t\treturn nonHex ?\n\n\t\t\t// Strip the backslash prefix from a non-hex escape sequence\n\t\t\tnonHex :\n\n\t\t\t// Replace a hexadecimal escape sequence with the encoded Unicode code point\n\t\t\t// Support: IE <=11+\n\t\t\t// For values outside the Basic Multilingual Plane (BMP), manually construct a\n\t\t\t// surrogate pair\n\t\t\thigh < 0 ?\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" +\n\t\t\t\tch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tinDisabledFieldset = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t( arr = slice.call( preferredDoc.childNodes ) ),\n\t\tpreferredDoc.childNodes\n\t);\n\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\t// eslint-disable-next-line no-unused-expressions\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpushNative.apply( target, slice.call( els ) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( ( target[ j++ ] = els[ i++ ] ) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\t\tsetDocument( context );\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( ( m = match[ 1 ] ) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( ( elem = context.getElementById( m ) ) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && ( elem = newContext.getElementById( m ) ) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[ 2 ] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!nonnativeSelectorCache[ selector + \" \" ] &&\n\t\t\t\t( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&\n\n\t\t\t\t// Support: IE 8 only\n\t\t\t\t// Exclude object elements\n\t\t\t\t( nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\" ) ) {\n\n\t\t\t\tnewSelector = selector;\n\t\t\t\tnewContext = context;\n\n\t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n\t\t\t\t// descendant combinators, which is not what we want.\n\t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n\t\t\t\t// list with an ID selector referencing the scope context.\n\t\t\t\t// The technique has to be used as well when a leading combinator is used\n\t\t\t\t// as such selectors are not recognized by querySelectorAll.\n\t\t\t\t// Thanks to Andrew Dupont for this technique.\n\t\t\t\tif ( nodeType === 1 &&\n\t\t\t\t\t( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\n\t\t\t\t\t// We can use :scope instead of the ID hack if the browser\n\t\t\t\t\t// supports it & if we're not changing the context.\n\t\t\t\t\tif ( newContext !== context || !support.scope ) {\n\n\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\tif ( ( nid = context.getAttribute( \"id\" ) ) ) {\n\t\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.setAttribute( \"id\", ( nid = expando ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[ i ] = ( nid ? \"#\" + nid : \":scope\" ) + \" \" +\n\t\t\t\t\t\t\ttoSelector( groups[ i ] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\tnonnativeSelectorCache( selector, true );\n\t\t\t\t} finally {\n\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn ( cache[ key + \" \" ] = value );\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement( \"fieldset\" );\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch ( e ) {\n\t\treturn false;\n\t} finally {\n\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split( \"|\" ),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[ i ] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( ( cur = cur.nextSibling ) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn ( name === \"input\" || name === \"button\" ) && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction( function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction( function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ ( j = matchIndexes[ i ] ) ] ) {\n\t\t\t\t\tseed[ j ] = !( matches[ j ] = seed[ j ] );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t} );\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\tvar namespace = elem && elem.namespaceURI,\n\t\tdocElem = elem && ( elem.ownerDocument || elem ).documentElement;\n\n\t// Support: IE <=8\n\t// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n\t// https://bugs.jquery.com/ticket/4833\n\treturn !rhtml.test( namespace || docElem && docElem.nodeName || \"HTML\" );\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( preferredDoc != document &&\n\t\t( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\n\t// Safari 4 - 5 only, Opera <=11.6 - 12.x only\n\t// IE/Edge & older browsers don't support the :scope pseudo-class.\n\t// Support: Safari 6.0 only\n\t// Safari 6.0 supports :scope but it's an alias of :root there.\n\tsupport.scope = assert( function( el ) {\n\t\tdocElem.appendChild( el ).appendChild( document.createElement( \"div\" ) );\n\t\treturn typeof el.querySelectorAll !== \"undefined\" &&\n\t\t\t!el.querySelectorAll( \":scope fieldset div\" ).length;\n\t} );\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert( function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute( \"className\" );\n\t} );\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert( function( el ) {\n\t\tel.appendChild( document.createComment( \"\" ) );\n\t\treturn !el.getElementsByTagName( \"*\" ).length;\n\t} );\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert( function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t} );\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[ \"ID\" ] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute( \"id\" ) === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[ \"ID\" ] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode( \"id\" );\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( ( elem = elems[ i++ ] ) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[ \"TAG\" ] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( ( elem = results[ i++ ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[ \"CLASS\" ] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {\n\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert( function( el ) {\n\n\t\t\tvar input;\n\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll( \"[msallowcapture^='']\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll( \"[selected]\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"~=\" );\n\t\t\t}\n\n\t\t\t// Support: IE 11+, Edge 15 - 18+\n\t\t\t// IE 11/Edge don't find elements on a `[name='']` query in some cases.\n\t\t\t// Adding a temporary attribute to the document before the selection works\n\t\t\t// around the issue.\n\t\t\t// Interestingly, IE 10 & older don't seem to have the issue.\n\t\t\tinput = document.createElement( \"input\" );\n\t\t\tinput.setAttribute( \"name\", \"\" );\n\t\t\tel.appendChild( input );\n\t\t\tif ( !el.querySelectorAll( \"[name='']\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" +\n\t\t\t\t\twhitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll( \":checked\" ).length ) {\n\t\t\t\trbuggyQSA.push( \":checked\" );\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push( \".#.+[+~]\" );\n\t\t\t}\n\n\t\t\t// Support: Firefox <=3.6 - 5 only\n\t\t\t// Old Firefox doesn't throw on a badly-escaped identifier.\n\t\t\tel.querySelectorAll( \"\\\\\\f\" );\n\t\t\trbuggyQSA.push( \"[\\\\r\\\\n\\\\f]\" );\n\t\t} );\n\n\t\tassert( function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement( \"input\" );\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll( \"[name=d]\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll( \":enabled\" ).length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll( \":disabled\" ).length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: Opera 10 - 11 only\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll( \"*,:x\" );\n\t\t\trbuggyQSA.push( \",.*:\" );\n\t\t} );\n\t}\n\n\tif ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector ) ) ) ) {\n\n\t\tassert( function( el ) {\n\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t} );\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( \"|\" ) );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( \"|\" ) );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t) );\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( ( b = b.parentNode ) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tcompare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tif ( a == document || a.ownerDocument == preferredDoc &&\n\t\t\t\tcontains( preferredDoc, a ) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tif ( b == document || b.ownerDocument == preferredDoc &&\n\t\t\t\tcontains( preferredDoc, b ) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t/* eslint-disable eqeqeq */\n\t\t\treturn a == document ? -1 :\n\t\t\t\tb == document ? 1 :\n\t\t\t\t/* eslint-enable eqeqeq */\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( ( cur = cur.parentNode ) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( ( cur = cur.parentNode ) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[ i ] === bp[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[ i ], bp[ i ] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t/* eslint-disable eqeqeq */\n\t\t\tap[ i ] == preferredDoc ? -1 :\n\t\t\tbp[ i ] == preferredDoc ? 1 :\n\t\t\t/* eslint-enable eqeqeq */\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\tsetDocument( elem );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!nonnativeSelectorCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\n\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t// fragment in IE 9\n\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\tnonnativeSelectorCache( expr, true );\n\t\t}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\n\t// Set document vars if needed\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( ( context.ownerDocument || context ) != document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\n\t// Set document vars if needed\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( ( elem.ownerDocument || elem ) != document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn ( sel + \"\" ).replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( ( elem = results[ i++ ] ) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( ( node = elem[ i++ ] ) ) {\n\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[ 1 ] = match[ 1 ].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[ 3 ] = ( match[ 3 ] || match[ 4 ] ||\n\t\t\t\tmatch[ 5 ] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[ 2 ] === \"~=\" ) {\n\t\t\t\tmatch[ 3 ] = \" \" + match[ 3 ] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[ 1 ] = match[ 1 ].toLowerCase();\n\n\t\t\tif ( match[ 1 ].slice( 0, 3 ) === \"nth\" ) {\n\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[ 3 ] ) {\n\t\t\t\t\tSizzle.error( match[ 0 ] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[ 4 ] = +( match[ 4 ] ?\n\t\t\t\t\tmatch[ 5 ] + ( match[ 6 ] || 1 ) :\n\t\t\t\t\t2 * ( match[ 3 ] === \"even\" || match[ 3 ] === \"odd\" ) );\n\t\t\t\tmatch[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === \"odd\" );\n\n\t\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[ 3 ] ) {\n\t\t\t\tSizzle.error( match[ 0 ] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[ 6 ] && match[ 2 ];\n\n\t\t\tif ( matchExpr[ \"CHILD\" ].test( match[ 0 ] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[ 3 ] ) {\n\t\t\t\tmatch[ 2 ] = match[ 4 ] || match[ 5 ] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t( excess = tokenize( unquoted, true ) ) &&\n\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t( excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length ) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[ 0 ] = match[ 0 ].slice( 0, excess );\n\t\t\t\tmatch[ 2 ] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() {\n\t\t\t\t\treturn true;\n\t\t\t\t} :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t( pattern = new RegExp( \"(^|\" + whitespace +\n\t\t\t\t\t\")\" + className + \"(\" + whitespace + \"|$)\" ) ) && classCache(\n\t\t\t\t\t\tclassName, function( elem ) {\n\t\t\t\t\t\t\treturn pattern.test(\n\t\t\t\t\t\t\t\ttypeof elem.className === \"string\" && elem.className ||\n\t\t\t\t\t\t\t\ttypeof elem.getAttribute !== \"undefined\" &&\n\t\t\t\t\t\t\t\t\telem.getAttribute( \"class\" ) ||\n\t\t\t\t\t\t\t\t\"\"\n\t\t\t\t\t\t\t);\n\t\t\t\t} );\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\t/* eslint-disable max-len */\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t\t/* eslint-enable max-len */\n\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, _argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, _context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( ( node = node[ dir ] ) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction( function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[ i ] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[ i ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t} ) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction( function( selector ) {\n\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction( function( seed, matches, _context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( ( elem = unmatched[ i ] ) ) {\n\t\t\t\t\t\t\tseed[ i ] = !( matches[ i ] = elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} ) :\n\t\t\t\tfunction( elem, _context, xml ) {\n\t\t\t\t\tinput[ 0 ] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[ 0 ] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t} ),\n\n\t\t\"has\": markFunction( function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t} ),\n\n\t\t\"contains\": markFunction( function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t} ),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test( lang || \"\" ) ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( ( elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute( \"xml:lang\" ) || elem.getAttribute( \"lang\" ) ) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t} ),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement &&\n\t\t\t\t( !document.hasFocus || document.hasFocus() ) &&\n\t\t\t\t!!( elem.type || elem.href || ~elem.tabIndex );\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn ( nodeName === \"input\" && !!elem.checked ) ||\n\t\t\t\t( nodeName === \"option\" && !!elem.selected );\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\t// eslint-disable-next-line no-unused-expressions\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[ \"empty\" ]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( ( attr = elem.getAttribute( \"type\" ) ) == null ||\n\t\t\t\t\tattr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo( function() {\n\t\t\treturn [ 0 ];\n\t\t} ),\n\n\t\t\"last\": createPositionalPseudo( function( _matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t} ),\n\n\t\t\"eq\": createPositionalPseudo( function( _matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t} ),\n\n\t\t\"even\": createPositionalPseudo( function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t\"odd\": createPositionalPseudo( function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t\"lt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ?\n\t\t\t\targument + length :\n\t\t\t\targument > length ?\n\t\t\t\t\tlength :\n\t\t\t\t\targument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t\"gt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} )\n\t}\n};\n\nExpr.pseudos[ \"nth\" ] = Expr.pseudos[ \"eq\" ];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || ( match = rcomma.exec( soFar ) ) ) {\n\t\t\tif ( match ) {\n\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[ 0 ].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( ( tokens = [] ) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( ( match = rcombinators.exec( soFar ) ) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push( {\n\t\t\t\tvalue: matched,\n\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[ 0 ].replace( rtrim, \" \" )\n\t\t\t} );\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||\n\t\t\t\t( match = preFilters[ type ]( match ) ) ) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push( {\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t} );\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[ i ].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || ( elem[ expando ] = {} );\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] ||\n\t\t\t\t\t\t\t( outerCache[ elem.uniqueID ] = {} );\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( ( oldCache = uniqueCache[ key ] ) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn ( newCache[ 2 ] = oldCache[ 2 ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[ i ]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[ 0 ];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[ i ], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( ( elem = unmatched[ i ] ) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction( function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts(\n\t\t\t\tselector || \"*\",\n\t\t\t\tcontext.nodeType ? [ context ] : context,\n\t\t\t\t[]\n\t\t\t),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( ( elem = temp[ i ] ) ) {\n\t\t\t\t\tmatcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) ) {\n\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( ( matcherIn[ i ] = elem ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, ( matcherOut = [] ), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) &&\n\t\t\t\t\t\t( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {\n\n\t\t\t\t\t\tseed[ temp ] = !( results[ temp ] = elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t} );\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[ 0 ].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[ \" \" ],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t( checkContext = context ).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {\n\t\t\tmatchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[ j ].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\n\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\ttokens\n\t\t\t\t\t\t.slice( 0, i - 1 )\n\t\t\t\t\t\t.concat( { value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" } )\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[ \"TAG\" ]( \"*\", outermost ),\n\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\n\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\toutermostContext = context == document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\n\t\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\t\tif ( !context && elem.ownerDocument != document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( ( matcher = elementMatchers[ j++ ] ) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( ( elem = !matcher && elem ) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( ( matcher = setMatchers[ j++ ] ) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !( unmatched[ i ] || setMatched[ i ] ) ) {\n\t\t\t\t\t\t\t\tsetMatched[ i ] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[ i ] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache(\n\t\t\tselector,\n\t\t\tmatcherFromGroupMatchers( elementMatchers, setMatchers )\n\t\t);\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( ( selector = compiled.selector || selector ) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[ 0 ] = match[ 0 ].slice( 0 );\n\t\tif ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === \"ID\" &&\n\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {\n\n\t\t\tcontext = ( Expr.find[ \"ID\" ]( token.matches[ 0 ]\n\t\t\t\t.replace( runescape, funescape ), context ) || [] )[ 0 ];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[ \"needsContext\" ].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[ i ];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ ( type = token.type ) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( ( find = Expr.find[ type ] ) ) {\n\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( ( seed = find(\n\t\t\t\t\ttoken.matches[ 0 ].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext\n\t\t\t\t) ) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split( \"\" ).sort( sortOrder ).join( \"\" ) === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert( function( el ) {\n\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement( \"fieldset\" ) ) & 1;\n} );\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert( function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute( \"href\" ) === \"#\";\n} ) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t} );\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert( function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n} ) ) {\n\taddHandle( \"value\", function( elem, _name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t} );\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert( function( el ) {\n\treturn el.getAttribute( \"disabled\" ) == null;\n} ) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t\t}\n\t} );\n}\n\n// EXPOSE\nvar _sizzle = window.Sizzle;\n\nSizzle.noConflict = function() {\n\tif ( window.Sizzle === Sizzle ) {\n\t\twindow.Sizzle = _sizzle;\n\t}\n\n\treturn Sizzle;\n};\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( function() {\n\t\treturn Sizzle;\n\t} );\n\n// Sizzle requires that there be a global window in Common-JS like environments\n} else if ( typeof module !== \"undefined\" && module.exports ) {\n\tmodule.exports = Sizzle;\n} else {\n\twindow.Sizzle = Sizzle;\n}\n\n// EXPOSE\n\n} )( window );\n\n\n\n// WEBPACK FOOTER //\n// ./~/sizzle/dist/sizzle.js","export { default as select, getSingleSelector, getMultiSelector } from './select'\nexport { default as match, initOptions } from './match'\nexport { default as optimize } from './optimize'\nexport * as common from './common'\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}